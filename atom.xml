<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Chris's Blog]]></title>
  <link href="http://askcuix.github.io/atom.xml" rel="self"/>
  <link href="http://askcuix.github.io/"/>
  <updated>2014-02-11T13:14:05+08:00</updated>
  <id>http://askcuix.github.io/</id>
  <author>
    <name><![CDATA[Chris]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[基于Spring Mobile开发移动Web应用]]></title>
    <link href="http://askcuix.github.io/blog/2014/02/11/develop-mobile-web-application-base-on-spring-mobile/"/>
    <updated>2014-02-11T12:22:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2014/02/11/develop-mobile-web-application-base-on-spring-mobile</id>
    <content type="html"><![CDATA[<p>最近在开发FX Trading的Dashboard的时候，发现用到的一些Bootstrap的样式在手机上的显示效果很不好，而且每笔trade包含的信息也比较多，用手机看实在是不方便，于是就萌生了做一版针对mobile的想法。</p>

<p>Spring Mobile还在1.0的beta版的时候就有了解过，但当时的版本还比较简陋，有些功能都不够完整，其实现在也都比较简单，总共也没多少代码，不过也足以解决mobile相关的一些问题了。Spring Mobile是基于Spring MVC的，如果你的项目本身使用的就是Spring MVC，那基本没多少额外的工作量。我们的项目就是基于Spring MVC的，现在也只是想增加针对mobile的展示，所以controller都可以重用，只需做一些针对mobile的页面就可以了。</p>

<p>Spring Mobile实现的功能主要包括以下四块，也都是配置一下就可以使用了，所以你只需要专注于页面的展示。</p>

<h2>Device Resolution</h2>

<p>访问设备的识别，默认采用LiteDeviceResolver作为实现，通过分析HTTP Header来进行识别，如User-Agent，Accept等。</p>

<p>若是一些特殊的User-Agent被识别成了mobile，可以将这些特殊的User-Agent的关键字定义为一个List<String>，作为LiteDeviceResolver的构造函数的参数，这些User-Agent将会被作为PC来处理。</p>

<p>每个request被处理之前，将会先识别设备类型Device，然后保存在request的<strong>currentDevice</strong>参数中。</p>

<!-- more -->


<p>定义DeviceResolverHandlerInterceptor在Spring MVC的配置中，即可实现设备的自动识别。</p>

<pre><code>&lt;interceptors&gt;
      &lt;!-- resolve the device that originated the web request --&gt;
      &lt;bean class="org.springframework.mobile.device.DeviceResolverHandlerInterceptor" /&gt;
&lt;/interceptors&gt; 
</code></pre>

<p>也可以通过在web.xml中定义DeviceResolverRequestFilter，来实现设备的自动识别。</p>

<pre><code>&lt;filter&gt;
     &lt;filter-name&gt;deviceResolverRequestFilter&lt;/filter-name&gt;
     &lt;filter-class&gt;org.springframework.mobile.device.DeviceResolverRequestFilter&lt;/filter-class&gt;
&lt;/filter&gt; 
</code></pre>

<p>若要在代码中获取当前设备类型，可以通过以下三种方式：</p>

<p>1、直接从HttpRequest中获取currentDevice参数。</p>

<p>2、使用DeviceUtils，但需要一个ServletRequest或Spring WebRequest作为参数。</p>

<pre><code> Device currentDevice = DeviceUtils.getCurrentDevice(servletRequest); 
</code></pre>

<p>3、将Device作为Controller中方法的参数，需要添加以下配置。</p>

<pre><code> &lt;annotation-driven&gt;
      &lt;argument-resolvers&gt;
           &lt;bean class="org.springframework.mobile.device.DeviceWebArgumentResolver" /&gt;
      &lt;/argument-resolvers&gt;
 &lt;/annotation-driven&gt; 
</code></pre>

<h2>Site Preference</h2>

<p>用于管理web应用采用哪种模式展现给用户。</p>

<p>默认采用StandardSitePreferenceHandler作为实现，首先从request中读取<strong>site_preference</strong>参数，并将读取到的设备类型保存在cookie中；若没读取到，则尝试从cookie中获取<strong>CookieSitePreferenceRepository.SITE_PREFERENCE</strong>，若仍然没有获取到，则采用DeviceResolver得到的设备类型；最终采用的设备类型将会保存在request的<strong>currentSitePreference</strong>参数中。</p>

<p>site_preference支持：normal，mobile和tablet。不区分大小写。 如：</p>

<pre><code>&lt;a href="${currentUrl}?site_preference=mobile"&gt;Mobile&lt;/a&gt;
</code></pre>

<p>定义SitePreferenceHandlerInterceptor在Spring MVC的配置中，即可实现Site Preference管理。</p>

<pre><code>&lt;interceptors&gt;
     &lt;!-- manage the user's site preference (declare after DeviceResolverHandlerInterceptor) --&gt;
     &lt;bean class="org.springframework.mobile.device.site.SitePreferenceHandlerInterceptor" /&gt;
&lt;/interceptors&gt;
</code></pre>

<p>若要在代码中获取当前的Site Preference，可以通过一下三种方式：</p>

<p>1、直接从HttpRequest中获取currentSitePreference参数。</p>

<p>2、使用SitePreferenceUtils，但需要一个ServletRequest或Spring WebRequest作为参数。</p>

<pre><code>  SitePreference sitePreference = SitePreferenceUtils.getCurrentSitePreference(servletRequest);
</code></pre>

<p>3、将SitePreference作为Controller中方法的参数，需要添加以下配置。</p>

<pre><code>  &lt;annotation-driven&gt;
       &lt;argument-resolvers&gt;
             &lt;bean class="org.springframework.mobile.device.site.SitePreferenceWebArgumentResolver" /&gt;
       &lt;/argument-resolvers&gt;
  &lt;/annotation-driven&gt;
</code></pre>

<h2>Site Switch</h2>

<p>Site Switch用于移动版和桌面版采用不同domain的应用，如：<em>m.google.com</em> 和 <em>google.com</em>。</p>

<p>Site Switch默认采用StandardSitePreferenceHandler作为Site Preference的实现，因此不需要再配置SitePreferenceHandlerInterceptor。</p>

<h3>mDot</h3>

<p>用于重定向mobile用户到<strong>m.${serverName}</strong>。</p>

<p>定义SiteSwitcherHandlerInterceptor在Spring MVC的配置中：</p>

<pre><code>  &lt;interceptors&gt;
        &lt;!-- resolve the device that originated the web request --&gt;
        &lt;bean class="org.springframework.mobile.device.DeviceResolverHandlerInterceptor" /&gt;


        &lt;!-- redirects mobile users to "m.myapp.com" (declare after DeviceResolverHandlerInterceptor) --&gt;
        &lt;bean class=“org.springframework.mobile.device.switcher.SiteSwitcherHandlerInterceptor" factory-method="mDot"&gt;
              &lt;constructor-arg index="0" type="java.lang.String" value="myapp.com"/&gt;
              &lt;constructor-arg index="1" type="java.lang.Boolean" value="true"/&gt;
        &lt;/bean&gt;
 &lt;/interceptors&gt;
</code></pre>

<p>第一个参数用于指定serverName，必须的参数；第二个为可选参数，用于指定是否将tablet作为mobile来处理。</p>

<h3>dotMobi</h3>

<p>用于重定向mobile用户到<strong>${serverName - lastDomain}.mobi</strong>。</p>

<p>定义SiteSwitcherHandlerInterceptor在Spring MVC的配置中：</p>

<pre><code>  &lt;interceptors&gt;
        &lt;!-- resolve the device that originated the web request --&gt;
        &lt;bean class="org.springframework.mobile.device.DeviceResolverHandlerInterceptor" /&gt;


        &lt;!-- redirects mobile users to "myapp.mobi" (declare after DeviceResolverHandlerInterceptor) --&gt;
        &lt;bean class=“org.springframework.mobile.device.switcher.SiteSwitcherHandlerInterceptor" factory-method="dotMobi"&gt;
              &lt;constructor-arg index="0" type="java.lang.String" value="myapp.com"/&gt;
              &lt;constructor-arg index="1" type="java.lang.Boolean" value="true"/&gt;
        &lt;/bean&gt;
 &lt;/interceptors&gt;
</code></pre>

<p>第一个参数用于指定serverName，必须的参数；第二个为可选参数，用于指定是否将tablet作为mobile来处理。</p>

<h3>Standard</h3>

<p>用于重定向mobile和tablet用户到指定的domain。</p>

<p>定义SiteSwitcherHandlerInterceptor在Spring MVC的配置中：</p>

<pre><code>  &lt;interceptors&gt;
        &lt;!-- resolve the device that originated the web request --&gt;
        &lt;bean class="org.springframework.mobile.device.DeviceResolverHandlerInterceptor" /&gt;


        &lt;!-- redirects mobile users to "mobile.app.com" (declare after DeviceResolverHandlerInterceptor) --&gt;
        &lt;bean class=“org.springframework.mobile.device.switcher.SiteSwitcherHandlerInterceptor" factory-method="standard"&gt;
              &lt;constructor-arg value="app.com"/&gt;
              &lt;constructor-arg value="mobile.app.com"/&gt;
              &lt;constructor-arg value="tablet.app.com"/&gt;
              &lt;constructor-arg value=".app.com"/&gt;
        &lt;/bean&gt;
 &lt;/interceptors&gt;
</code></pre>

<p>第一个参数用于指定serverName；第二个参数用于指定mobile的domain，第三个参数用于指定tablet的domain，第四个参数用于指定cookie的domain。</p>

<h3>urlPath</h3>

<p>用于重定向mobile用户到相同domain下的不同的路径 <strong>${serverName}/${mobilePath}</strong>。</p>

<p>定义SiteSwitcherHandlerInterceptor在Spring MVC的配置中：</p>

<pre><code>  &lt;interceptors&gt;
        &lt;!-- resolve the device that originated the web request --&gt;
        &lt;bean class="org.springframework.mobile.device.DeviceResolverHandlerInterceptor" /&gt;


        &lt;!-- redirects mobile users to "myapp.com/m" (declare after DeviceResolverHandlerInterceptor) --&gt;
        &lt;bean class=“org.springframework.mobile.device.switcher.SiteSwitcherHandlerInterceptor" factory-method="urlPath"&gt;
              &lt;constructor-arg index="0" type="java.lang.String" value="/m" /&gt;
        &lt;/bean&gt;
 &lt;/interceptors&gt;
</code></pre>

<p>参数用于指定mobile的路径。</p>

<p>若应用不在domain的根路径下，可指定root path。</p>

<pre><code>&lt;interceptors&gt;
        &lt;!-- resolve the device that originated the web request --&gt;
        &lt;bean class="org.springframework.mobile.device.DeviceResolverHandlerInterceptor" /&gt;


        &lt;!-- redirects mobile users to "myapp.com/showcase/m" (declare after DeviceResolverHandlerInterceptor) --&gt;
        &lt;bean class=“org.springframework.mobile.device.switcher.SiteSwitcherHandlerInterceptor" factory-method="urlPath"&gt;
              &lt;constructor-arg index="0" type="java.lang.String" value="/m" /&gt;
              &lt;constructor-arg index="1" type="java.lang.String" value="/showcase" /&gt;
        &lt;/bean&gt;
 &lt;/interceptors&gt;
</code></pre>

<p>第一个参数用于指定mobile的路径，第二个参数用于指定应用的root path。</p>

<p>以上两种配置都会将tablet作为PC来处理，如需指定tablet的路径，可通过如下的配置。</p>

<pre><code> &lt;interceptors&gt;
        &lt;!-- resolve the device that originated the web request --&gt;
        &lt;bean class="org.springframework.mobile.device.DeviceResolverHandlerInterceptor" /&gt;


        &lt;!-- redirects mobile users to "myapp.com/showcase/m" (declare after DeviceResolverHandlerInterceptor) --&gt;
        &lt;bean class=“org.springframework.mobile.device.switcher.SiteSwitcherHandlerInterceptor" factory-method="urlPath"&gt;
              &lt;constructor-arg index="0" type="java.lang.String" value="/m" /&gt;
              &lt;constructor-arg index="1" type="java.lang.String" value="/t" /&gt;
              &lt;constructor-arg index="2" type="java.lang.String" value="/showcase" /&gt;
        &lt;/bean&gt;
 &lt;/interceptors&gt;
</code></pre>

<p>为了让mobile和tablet的路径能够正常工作，还需要在web.xml中配置相应的url给DispatcherServlet。</p>

<pre><code>  &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
        &lt;url-pattern&gt;/m/*&lt;/url-pattern&gt;
        &lt;url-pattern&gt;/t/*&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
</code></pre>

<h2>Device Aware View Management</h2>

<p>根据设备类型来决定使用的view，避免了在Controller中判断设备类型来返回特定view的繁琐。LiteDeviceDelegatingViewResolver可以在不同的路径下查找相同名字的view，也可以在相同路径下查找不同后缀的view。</p>

<p>在Spring MVC的配置中添加如下定义：</p>

<pre><code>   &lt;bean class="org.springframework.mobile.device.view.LiteDeviceDelegatingViewResolver"&gt;
         &lt;constructor-arg&gt;
               &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;
                     &lt;property name="prefix" value="/WEB-INF/views/" /&gt;
                     &lt;property name="suffix" value=".jsp" /&gt;
              &lt;/bean&gt;
         &lt;/constructor-arg&gt;
         &lt;property name="mobilePrefix" value="mobile/" /&gt;
         &lt;property name="tabletPrefix" value="tablet/" /&gt;
         &lt;property name="enableFallback" value="true" /&gt;
   &lt;/bean&gt;
</code></pre>

<p>enableFallback用于若找不到调整路径后的view，则使用原始的view。这是一个很好的特性，但是在Spring MVC并没有真正实现它，所以这个参数是不起作用的。</p>

<p>可参见spring的issue list：</p>

<p><a href="https://jira.springsource.org/browse/MOBILE-76?page=com.atlassian.jira.plugin.system.issuetabpanels">Spring Mobile / MOBILE-76</a></p>

<p><a href="https://jira.springsource.org/browse/SPR-7727?page=com.atlassian.jira.plugin.system.issuetabpanels">Spring Framework / SPR-7727</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go语言基础]]></title>
    <link href="http://askcuix.github.io/blog/2014/01/24/go-programming-foundations/"/>
    <updated>2014-01-24T16:28:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2014/01/24/go-programming-foundations</id>
    <content type="html"><![CDATA[<p>Go语言常被拿来和C与Python进行比较，Go语言在语法上确实和C与Python有很多的相似性，不过这两种语言我都不太擅长，C语言仅局限在大学的课本上，Python倒是之前用来写过一些安装脚本。总之，我是不够资格去评论Go与这两种语言的差别了，在学习的过程中，倒是会与Java做些比较，其实多少也有些相似性。</p>

<h2>package</h2>

<p><strong>package <em>&lt;pkgName></em></strong> 定义当前文件属于哪个包。</p>

<p>包名如果是main，则表明它是一个可独立运行的包，它在编译后会产生可执行文件。除了main包之外，其它的包最后都会生成*.a文件（也就是包文件），并放置在$GOPATH/pkg/$GOOS_$GOARCH中（以Mac为例就是$GOPATH/pkg/darwin_amd64）。</p>

<p>每一个可独立运行的Go程序，必定包含一个package main，在这个main包中必定包含一个入口函数main，main函数既没有参数，也没有返回值。</p>

<p>包名和包所在的文件夹名可以是不同的，<em>&lt;pkgName></em> 即为通过 <em>package &lt;pkgName></em> 声明的包名，而非文件夹名。</p>

<!-- more -->


<h2>import</h2>

<p>import用来导入包文件。除了标准库之外，import还支持如下两种方式来加载自己写的模块：</p>

<p>1、相对路径</p>

<pre><code>  import “./model”  //与当前文件同一目录的model目录，但是不建议使用 
</code></pre>

<p>2、绝对路径</p>

<pre><code>  import “shorturl/model”  //加载gopath/src/shorturl/model模块 
</code></pre>

<p>import的几种特殊使用方式：</p>

<p>1、点操作</p>

<pre><code>  import(
     . "fmt"
  )
</code></pre>

<p>   点操作的含义就是这个包导入之后，在调用这个包的函数时，可以省略前缀的包名，也就是将 <em>fmt.Println(&#8220;hello world&#8221;)</em> 简写成 <em>Println(&#8220;hello world”)</em>。</p>

<p>2、别名操作</p>

<pre><code>  import(
      f "fmt"
  )
</code></pre>

<p>   调用包函数时前缀变成了别名，即 <em>f.Println(&#8220;hello world”)</em>。</p>

<p>3、_操作</p>

<pre><code> import (
     "database/sql"
     _ "github.com/ziutek/mymysql/godrv"
 )
</code></pre>

<p>   _操作就是引入该包，而不直接使用包里面的函数，只是调用了该包里面的init函数。</p>

<h2>变量</h2>

<p>定义变量的标准方式：</p>

<pre><code> var varName type
</code></pre>

<p>定义多个变量：</p>

<pre><code> var vname1, vname2, vname3 type
</code></pre>

<p>定义变量并初始化值：</p>

<pre><code> var varName type = value
</code></pre>

<p>定义并初始化多个变量：</p>

<pre><code> var vname1, vname2, vname3 type= v1, v2, v3
</code></pre>

<p>可以忽略类型声明，Go会根据其值的类型来初始化。</p>

<p>简短声明：</p>

<pre><code> vname1, vname2, vname3 := v1, v2, v3
</code></pre>

<p><strong>:=</strong> 取代了var和type，但只能用在函数内部，在函数外部使用会无法编译通过，所以一般用var方式来定义全局变量。</p>

<p><strong>_</strong>（下划线）是个特殊的变量名，任何赋予它的值都会被丢弃。</p>

<p>另外需要注意的是，<strong>Go对于已声明但未使用的变量会在编译阶段报错</strong>。</p>

<h2>常量</h2>

<p>定义常量的标准方式：</p>

<pre><code> const constantName type = value
</code></pre>

<p>类型声明可以忽略。</p>

<p>定义一组常量就可以作为enum：</p>

<pre><code> const(
    x = iota // x == 0
    y = iota // y == 1
    z = iota // z == 2
 )
</code></pre>

<p>这里的<strong>iota</strong>，在声明enum的时候采用，它默认开始值是0，每调用一次加1，每遇到一个const关键字，iota就会重置。</p>

<p>若一行定义多个常量的值为iota，则这些常量的值相同。</p>

<pre><code> const(
    x, y, z = iota, iota, iota  // x=0, y=0, z=0
 )
</code></pre>

<h2>数据类型</h2>

<p>Go语言中约定变量名或函数名的定义方式决定可访问性：</p>

<p>大写字母开头的变量是公用变量，其它包可以读取；小写字母开头是私有变量。</p>

<p>大写字母开头的函数也是一样，相当于Java中的public方法；小写字母开头的就是private方法。</p>

<h3>Boolean</h3>

<p>布尔值的类型为bool，值是true或false，默认为false。</p>

<h3>数值类型</h3>

<p>整数类型有无符号int和带符号uint两种。这两种类型的长度相同，但具体长度取决于不同编译器的实现，通常为32位。</p>

<p>Go里面也有直接定义好位数的类型：rune, int8, int16, int32, int64和byte, uint8, uint16, uint32, uint64。其中rune是int32的别名，byte是uint8的别名。这些类型的变量之间不允许互相赋值或操作，否则会在编译时报错。</p>

<p>浮点数类型有float32和float64两种（没有float类型），默认是float64。</p>

<p>复数类型有complex128（64位实数+64位虚数）和complex64(32位实数+32位虚数)两种。复数的形式为RE + IMi，其中RE是实数部分，IM是虚数部分，而最后的i是虚数单位。</p>

<h3>字符串</h3>

<p>Go中的字符串都是采用UTF-8字符集编码。字符串是用一对双引号 <strong>&#8221; &#8221;</strong> 或反引号 <strong>` `</strong> 括起来定义，它的类型是string。</p>

<p>Go的字符串是不可变的，可以使用 <strong>+</strong> 操作符来连接两个字符串。</p>

<p>多行的字符串可以通过 <strong>`</strong> 来声明，<strong>`</strong> 括起的字符串为Raw字符串，即字符串在代码中的形式就是打印时的形式，没有字符转义。</p>

<h3>array</h3>

<p>array数组的定义方式：</p>

<pre><code> var arr [n]type
</code></pre>

<p>n表示数组的长度，type表示存储元素的类型。对数组的操作都是通过 <strong>[]</strong> 来进行读取或赋值。</p>

<p>由于长度也是数组类型的一部分，因此[3]int与[4]int是不同的类型，数组不能改变其长度。数组之间的赋值是值的赋值，即当把一个数组作为参数传入函数的时候，传入的其实是该数组的副本，而不是它的指针。</p>

<p>数组可以使用 <strong>:=</strong> 来声明：</p>

<pre><code> a := [3]int{1, 2, 3}  // 声明了一个长度为3的int数组

 b := [10]int{1, 2, 3}  // 声明了一个长度为10的int数组，其中前三个元素初始化为1、2、3，其它默认为0

 c := [...]int{4, 5, 6}  // 可以省略长度而采用 "..." 的方式，Go会自动根据元素个数来计算长度 
</code></pre>

<p>Go支持嵌套数组，即多维数组。</p>

<h3>slice</h3>

<p>slice动态数组并不是真正意义上的动态数组，而是一个引用类型。slice总是指向一个底层的array，slice的声明也可以像array一样，只是不需要指定长度。</p>

<p>slice和array在声明时的区别：声明数组时，方括号内写明了数组的长度或使用&#8230;自动计算长度，而声明slice时，方括号内没有任何字符。</p>

<p>slice可以通过 <em>array[i:j]</em> 来获取，其中i是数组的开始位置，j是结束位置，但不包含array[j]，它的长度是j-i。</p>

<p>slice的默认开始位置是0，<em>ar[:n]</em> 等价于 <em>ar[0:n]</em>。</p>

<p>slice的第二个序列默认是数组的长度，<em>ar[n:]</em> 等价于 <em>ar[n:len(ar)]</em>。</p>

<p>如果从一个数组里面直接获取slice，可以这样ar[:]，因为默认第一个序列是0，第二个是数组的长度，即等价于 <em>ar[0:len(ar)]</em>。</p>

<p>slice是引用类型，当引用改变其中元素的值时，其它的所有引用都会改变该值。</p>

<p>slice像一个结构体(struct)，这个结构体包含了三个元素：</p>

<p><strong>指针</strong> - 指向数组中slice指定的开始位置。<br/>
<strong>长度</strong> - slice的长度。<br/>
<strong>最大长度</strong> - slice开始位置到数组的最后位置的长度。</p>

<p>slice的常用内置函数：</p>

<p><strong>len</strong> - 获取slice的长度。<br/>
<strong>cap</strong> - 获取slice的最大容量。<br/>
<strong>append</strong> - 向slice里面追加一个或者多个元素，然后返回一个和slice一样类型的slice。<br/>
<strong>copy</strong> - 从源slice中复制元素到目标dest，并且返回复制的元素的个数。</p>

<h3>map</h3>

<p>map也就是Python中的字典，它的格式为：</p>

<pre><code> map[keyType]valueType
</code></pre>

<p>map是无序的，每次打印出来的map都会不一样，它不能通过index获取，而必须通过key获取。</p>

<p>map的长度是不固定的，和slice一样，也是一种引用类型。</p>

<p>内置的len函数同样适用于map，返回map拥有的key的数量。</p>

<p>map的值可以很方便的修改，通过 <em>numbers[&#8220;one&#8221;]=11</em> 可以很容易的把key为one的字典值改为11。</p>

<p>map和其他基本类型不同，它不是thread safe的，在多个goroutine存取时，必须使用mutex lock进行加锁。</p>

<p>map可以通过key:val的方式初始化值，同时map内置有判断是否存在key的方式。可以通过delete删除map的元素。</p>

<h2>流程控制</h2>

<h3>if</h3>

<p>if条件判断语句中没有圆括号，但需要有花括号。</p>

<p>if语句里面允许声明变量，这个变量的作用域是该条件逻辑块内。</p>

<h3>goto</h3>

<p>用goto跳转到在当前函数内定义的标签。标签名是大小写敏感的。</p>

<h3>for</h3>

<p>for条件语句不需要括号。</p>

<p>若需要进行多个赋值操作，由于Go里面没有,操作符，则需同时赋值多个变量，如：*i, j = i+1, j-1</p>

<p>若条件语句中只存在一个条件，则 <strong>;</strong> 也可以省略，相当于实现了while的功能，如：</p>

<pre><code> sum := 1

 for sum &lt; 1000 {
    sum += sum
 }
</code></pre>

<p><strong>break</strong>用于跳出当前循环，<strong>continue</strong>用于跳过本次循环。</p>

<p>break和continue还可以跟着标号，用来跳到多重循环中的外层循环。</p>

<p>for配合range可以用于读取slice和map的数据，如：</p>

<pre><code> for k,v:=range map {
    fmt.Println("map's key:",k)
    fmt.Println("map's val:",v)
 }   
</code></pre>

<p>由于Go支持 “多值返回”, 而对于 <strong>声明而未被调用</strong> 的变量, 编译器会报错, 在这种情况下, 可以使用 <strong>_</strong> 来丢弃不需要的返回值，如：</p>

<pre><code> for _, v := range map{
    fmt.Println("map's val:", v)
 } 
</code></pre>

<h3>switch</h3>

<p>switch表达式没有类型要求。case语句中可使用多个值。</p>

<p>默认每个case执行完成都会break，匹配成功后不会自动向下执行其他case，但是可以使用fallthrough强制执行后面的case代码。</p>

<p>default用于无匹配条件的case。</p>

<h2>函数</h2>

<p>函数通过关键字func来声明，格式如下：</p>

<pre><code> func funcName(input1 type1, input2 type2) (output1 type1, output2 type2) {
      // statement
      return value1, value2
  }
</code></pre>

<p>关键字func用来声明一个函数funcName；函数可以有一个或者多个参数，每个参数后面带有类型，通过,分隔；函数可以返回多个值。</p>

<p>返回值可以不声明变量只定义类型；如果只有一个返回值且不声明返回值变量，那么可以省略包括返回值的括号；如果没有返回值，那么就直接省略最后的返回信息；如果有返回值，那么必须在函数的外层添加return语句；如果定义了返回值变量，那么return语句可以不用带上变量名。</p>

<p>在Go中函数也是一种变量，可以通过type来定义它，它的类型就是所有拥有相同的参数，相同的返回值的一种类型：</p>

<pre><code> type typeName func(input1 inputType1 , input2 inputType2 [, ...]) (result1 resultType1 [, ...]) 
</code></pre>

<h3>变参</h3>

<p>Go函数支持变参，在函数体中，变参是一个slice。如：</p>

<pre><code> func myfunc(arg ...int) {} 
</code></pre>

<h3>传值与传指针</h3>

<p>当我们传一个参数值到被调用函数里面时，实际上是传了这个值的一份copy，当在被调用函数中修改参数值的时候，调用函数中相应实参不会发生任何变化，因为数值变化只作用在copy上。</p>

<p>传递引用是通过传指针来实现的。传指针使得多个函数能操作同一个对象。</p>

<p>传指针比较轻量级 (8bytes)，只是传内存地址，我们可以用指针传递体积大的结构体。如果用参数值传递的话, 在每次copy上面就会花费相对较多的系统开销（内存和时间）。</p>

<p>Go语言中string，slice，map这三种类型的实现机制类似指针，所以可以直接传递，而不用取地址后传递指针。若函数需改变slice的长度，则仍需要取地址传递指针。</p>

<h2>结构体struct</h2>

<p>struct的声明方式：</p>

<pre><code> type structName struct {}
</code></pre>

<p>struct的使用方式：</p>

<p>1、按照顺序提供初始化值。例如：</p>

<pre><code> P := person{"Tom", 25}
</code></pre>

<p>2、通过field:value的方式初始化，这样可以任意顺序。例如：</p>

<pre><code> P := person{age:24, name:"Tom"}
</code></pre>

<p>3、通过new函数分配一个指针。例如此处P的类型为*person：</p>

<pre><code> P := new(person) 
</code></pre>

<p>定义struct的时候，若字段只提供类型，而不写字段名，它就是匿名字段，也称为嵌入字段。</p>

<p>当匿名字段是一个struct的时候，那么这个struct所拥有的全部字段都被隐式地引入了当前定义的这个struct。</p>

<p>包含匿名字段的struct，若定义了与匿名字段类型中同名的字段，则可实现覆盖。</p>

<h3>method</h3>

<p>定义method的格式：</p>

<pre><code> func (r ReceiverType) funcName(parameters) (results)
</code></pre>

<p>receiver可以为任何类型。若receiver为指针类型，Go会自动将传入的实例变量转为指针，反之亦然。</p>

<p>若匿名字段实现了一个method，那么包含这个匿名字段的struct也能调用该method，通过这种方式实现method继承。</p>

<p>包含匿名字段的struct，若定义与匿名字段同名的method，则可实现method重写。</p>

<h2>interface</h2>

<p>interface是一组method的组合。</p>

<p>interface的声明方式：</p>

<pre><code> type interfaceName interface { }
</code></pre>

<p>空interface(<em>interface{}</em>)不包含任何的method，可以用于存储任意类型的数值。一个函数把interface{}作为参数，那么他可以接受任意类型的值作为参数，如果一个函数返回interface{}，那么也就可以返回任意类型的值。</p>

<p>在interface中定义interface类型的字段，即可继承该interface中的所有method。</p>

<h3>类型判断</h3>

<p>comma-ok判断变量的类型：</p>

<pre><code> value, ok = element.(T)
</code></pre>

<p>value是变量的值，ok是一个bool类型，element是interface变量，T是断言的类型。</p>

<p>switch测试变量的类型：</p>

<pre><code> switch value := element.(type) {
        case int:
            fmt.Printf("element is an int and its value is %d\n", value)
        case string:
            fmt.Printf(“element is a string and its value is %s\n", value)
        default:
            fmt.Println("element is of a different type", index)
  }
</code></pre>

<p>element.(type)语法不能在switch外的任何逻辑里面使用，如果要在switch外面判断一个类型就要使用comma-ok。</p>

<h2>内存分配</h2>

<p><strong>make</strong>用于内建类型（map、slice 和channel）的内存分配。</p>

<p><strong>new</strong>用于各种类型的内存分配。new(T)分配了零值填充的T类型的内存空间，并且返回其地址，即一个*T类型的值。</p>

<p>make(T, args)与new(T)有着不同的功能，make只能创建slice、map和channel，并且返回一个有初始值(非零)的T类型，而不是*T。</p>

<h2>错误处理</h2>

<h3>error</h3>

<p>Go内置有一个error类型，专门用来处理错误信息。</p>

<p>自定义error类型可以通过实现error接口的Error方法。</p>

<h3>defer</h3>

<p>defer延迟语句，当函数执行到最后时，defer语句会按照逆序执行，最后该函数返回。</p>

<p>多个defer是采用后进先出模式。</p>

<h3>Panic</h3>

<p>panic 是一个内建函数，类似于异常处理，可以中断原有的控制流程。当函数F调用panic，函数F的执行被中断，但是F中的延迟函数会正常执行，然后F返回到调用它的地方。这一过程继续向上，直到发生panic的goroutine中所有调用的函数返回，此时程序退出。panic可以由直接调用panic产生，也可以由运行时错误产生。</p>

<h3>Recover</h3>

<p>recover 是一个内建的函数，可以让出现panic的流程中的goroutine恢复过来。recover仅在延迟函数中有效。在正常的执行过程中，调用recover会返回nil，并且没有其它任何效果。如果当前的goroutine出现panic，调用recover可以捕获到panic的输入值，并且恢复正常的执行。</p>

<p>panic类似java中的throw exception，recover类似catch exception。</p>

<h2>main() &amp;&amp; init()</h2>

<p>init函数能够应用于所有的package，main函数只能应用于package main。这两个函数在定义时不能有任何的参数和返回值。Go程序会自动调用init()和main()，所以你不需要主动调用这两个函数。每个package中的init函数是可选的，但package main就必须包含一个main函数。</p>

<p>虽然一个package里面可以写任意多个init函数，但从可读性和可维护性来说，建议在一个package中只有一个init函数。</p>

<p>程序的初始化和执行都起始于main包。如果main包还导入了其它的包，那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，那么它只会被导入一次。当一个包被导入时，如果该包还导入了其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行init函数（如果有的话）。等所有被导入的包都加载完毕了，就会开始对main包中的包级常量和变量进行初始化，然后执行main包中的init函数（如果存在的话），最后执行main函数。</p>

<h2>反射</h2>

<p>反射需要先将值通过reflect.TypeOf或者reflect.ValueOf转化成reflect对象。</p>

<pre><code> t := reflect.TypeOf(i)    //得到类型的元数据
 v := reflect.ValueOf(i)   //得到实际的值
</code></pre>

<p>如果需要修改反射的字段，转换成reflect对象的时候需要传入指针。</p>

<h2>并发处理</h2>

<h3>goroutine</h3>

<p>goroutine本质就是线程，是通过Go的runtime管理的一个线程管理器。通过关键字go就可以启动一个goroutine。</p>

<p>默认情况下，调度器仅使用单线程，如果一个goroutine没有被阻塞，那么其它的goroutine就不会被执行。想要发挥多核处理器的并行，需要在我们的程序中显式调用 <strong>runtime.GOMAXPROCS(n)</strong> 来告诉调度器同时使用多个线程。</p>

<h3>lock</h3>

<p>对于多个线程的并发处理，需要加锁来保证操作的准确性。在包sync中提供了Mutex用于对代码块进行加锁和解锁。</p>

<h3>atomic</h3>

<p>为保证变量的原子操作，在包sync/atomic中提供了很多原子操作的方法用于确保线程安全。</p>

<h3>channels</h3>

<p>goroutine运行在相同的地址空间，因此访问共享内存必须做好同步。goroutine之间使用channel进行数据的通信，可以通过它发送或者接收值。这些值只能是channel类型。定义一个channel时，也需要定义发送到channel的值的类型。</p>

<p>必须使用make 创建channel：</p>

<pre><code> channelName := make(chan type) 
</code></pre>

<p>channel通过操作符 <strong>&lt;-</strong> 来接收和发送数据，例如：</p>

<pre><code> ch &lt;- v    // 发送v到channel ch.
 v := &lt;-ch  // 从ch中接收数据，并赋值给v 
</code></pre>

<p>默认情况下，channel接收和发送数据都是阻塞的，除非另一端已经准备好，这样就使得goroutine同步变的更加的简单，而不需要显式的lock。所谓阻塞，也就是如果读取（<em>value := &lt;-ch</em>）将会被阻塞，直到有数据接收。其次，任何发送（<em>ch&lt;-5</em>）将会被阻塞，直到数据被读出。</p>

<h3>Buffered Channels</h3>

<p>Go允许指定channel的缓冲大小，就是channel可以存储多少元素。</p>

<p>例如：<em>ch:= make(chan bool, 4)</em></p>

<p>创建了可以存储4个元素的bool型channel。在这个channel中，前4个元素可以无阻塞的写入。当写入第5个元素时，代码将会阻塞，直到其他goroutine从channel中读取一些元素，腾出空间。</p>

<p>Buffered Channels的定义方式：</p>

<pre><code> channelName := make(chan type, value)
</code></pre>

<h3>Range &amp;&amp; Close</h3>

<p>可以通过range，像操作slice一样操作缓存类型的channel。</p>

<p><code>for i := range c</code> 能够不断的读取channel里面的数据，直到该channel被显式的关闭。生产者通过close函数关闭channel。关闭channel之后就无法再发送任何数据了，在消费方可以通过语法 <code>v, ok := &lt;-ch</code> 测试channel是否被关闭。如果ok返回false，那么说明channel已经没有任何数据并且已经被关闭。</p>

<p>一定要在生产者的地方关闭channel，而不是消费的地方去关闭它，这样容易引起panic。</p>

<p>channel不像文件之类的，不需要经常去关闭，只有当你确实没有任何发送数据了，或者你想显式的结束range循环之类的。</p>

<h3>Select</h3>

<p>如果存在多个channel的时候，通过select可以监听channel上的数据流动。</p>

<p>select默认是阻塞的，只有当监听的channel中有发送或接收可以进行时才会运行，当多个channel都准备好的时候，select是随机的选择一个执行的。</p>

<p>可以在select中设置超时，避免整个程序进入阻塞的情况。</p>

<p>例如：</p>

<pre><code> select {
     case v := &lt;- c:
             println(v)
     case &lt;- time.After(5 * time.Second):
             println("timeout")
             o &lt;- true
             break
 }  
</code></pre>

<p>select的语法类似于switch，default就是当监听的channel都没有准备好的时候执行，这样就不会阻塞等待channel。</p>

<h3>goroutine的相关函数</h3>

<p>runtime包中有几个处理goroutine的常用函数：</p>

<p><strong>Goexit</strong></p>

<p>退出当前执行的goroutine，但是defer函数还会继续调用</p>

<p><strong>Gosched</strong></p>

<p>让出当前goroutine的执行权限，调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行。</p>

<p><strong>NumCPU</strong></p>

<p>返回 CPU 核数量</p>

<p><strong>NumGoroutine</strong></p>

<p>返回正在执行和排队的任务总数</p>

<p><strong>GOMAXPROCS</strong></p>

<p>用来设置可以并行计算的CPU核数的最大值，并返回之前的值。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Postgresql常用命令]]></title>
    <link href="http://askcuix.github.io/blog/2014/01/24/the-command-of-postgresql/"/>
    <updated>2014-01-24T10:37:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2014/01/24/the-command-of-postgresql</id>
    <content type="html"><![CDATA[<p>Postgresql提供了很多快捷的命令，可以很方便的在命令行中使用。以<strong>\</strong>开头的命令需要进入psql执行。</p>

<h2>数据库管理</h2>

<p><strong>创建用户</strong></p>

<pre><code>CREATE USER chris WITH CREATEDB ENCRYPTED PASSWORD '123456';
</code></pre>

<p><strong>更改用户</strong></p>

<pre><code>ALTER USER chris WITH ENCRYPTED PASSWORD 'chris123';
</code></pre>

<p><strong>列出所有的Roles</strong></p>

<pre><code>SELECT rolname FROM pg_roles;

or

\du 
</code></pre>

<p><strong>创建Database</strong></p>

<pre><code>CREATE DATABASE dbname;

or

createdb dbname
</code></pre>

<p><strong>Grant Right</strong></p>

<pre><code>GRANT ALL PRIVILEGES ON DATABASE mydb to chris;
</code></pre>

<p><strong>创建Database并指定Role</strong></p>

<pre><code>CREATE DATABASE dbname OWNER rolename;

or

createdb -O rolename dbname
</code></pre>

<p><strong>删除Database</strong></p>

<pre><code>DROP DATABASE name;

or

dropdb dbname
</code></pre>

<p><strong>列出所有的Databases</strong></p>

<pre><code>SELECT datname FROM pg_database;

or

\l
</code></pre>

<p><strong>切换Database</strong></p>

<pre><code>\c dbname
</code></pre>

<p><strong>列出所有的Tablespaces</strong></p>

<pre><code>SELECT spcname FROM pg_tablespace;

or

\db
</code></pre>

<p><strong>列出当前Database的所有Tables</strong></p>

<pre><code>\dt
</code></pre>

<p><strong>查看Table</strong></p>

<pre><code>\d tablename
</code></pre>

<p><strong>列出当前Database的所有Functions</strong></p>

<pre><code>\df
</code></pre>

<!-- more -->


<h2>系统管理</h2>

<p>以下Postgresql相关的路径信息以Ubuntu为例。</p>

<h3>启动/停止服务</h3>

<p>启动Postgresql服务：</p>

<pre><code>sudo /etc/init.d/postgresql start
</code></pre>

<p>停止Postgresql服务：</p>

<pre><code>sudo /etc/init.d/postgresql stop
</code></pre>

<p>重启Postgresql服务：</p>

<pre><code>sudo /etc/init.d/postgresql reload
</code></pre>

<h3>检查Postgresql进程</h3>

<pre><code>ps auxww | grep ^postgres
</code></pre>

<h3>Database Log</h3>

<pre><code>/var/log/postgresql  
</code></pre>

<h3>查看系统参数</h3>

<pre><code>show &lt;parm_name&gt;
</code></pre>

<h3>查看连接数</h3>

<pre><code>select count(1) from pg_stat_activity; 
</code></pre>

<h3>数据库备份</h3>

<pre><code>pg_dump -h host -p port -U user dbname &gt; outfile
</code></pre>

<h3>数据库恢复</h3>

<pre><code>psql -h host -p port dbname &lt; infile
</code></pre>

<h3>开启远程访问</h3>

<p>在postgresql.conf中更改listen_addresses：</p>

<pre><code>sudo vi /etc/postgresql/9.1/main/postgresql.conf       

listen_addresses="*"
</code></pre>

<p>在pg_hba.conf中添加host：</p>

<pre><code>sudo vi /etc/postgresql/9.1/main/pg_hba.conf

host  all  all 0.0.0.0/0  md5
</code></pre>

<h3>调整Database的最大连接数</h3>

<p>Postgresql的最大连接数默认是100，如果我们同时有很多程序一起连接，有时是不够用的，可以postgresql.conf中的参数来调大连接数。</p>

<pre><code>sudo vi /etc/postgresql/9.1/main/postgresql.conf
</code></pre>

<p>更改以下两个参数的值：</p>

<pre><code>shared_buffers: 25% - 50% of the system RAM
max_connections: max_connections * work_mem &lt; RAM
</code></pre>

<p>更改之后需要重启Postgresql，如果遇到SHMMAX not enough的错误，则需要更改SHMMAX的大小。</p>

<pre><code>sudo vi /etc/sysctl.d/30-postgresql-shm.conf
</code></pre>

<p>更改kernel.shmmax的值，值的大小可以参考之前错误中的提示。</p>

<p>更改完之后需要reload configure:</p>

<pre><code>sudo service procps start
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting start with GoLang]]></title>
    <link href="http://askcuix.github.io/blog/2014/01/23/getting-start-with-go-lang/"/>
    <updated>2014-01-23T17:50:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2014/01/23/getting-start-with-go-lang</id>
    <content type="html"><![CDATA[<p>Go语言以简单、并行、高效等优点已推出了好几年，但真正影响到很多人去关注的，应该是在最近一年，Go被成功运用到云计算等领域，也出现了越来越多的拥护者。最近因为工作的需要，也开始关注一些并行计算方面的东西，并行作为Go的一大卖点，自然要去了解一下。</p>

<p>我在Mac下先用HomeBrew安装了Go，不过发现安装出来的包不够全，没有godoc，其它还少了什么东西就没去仔细看了，然后还是从官方下载tar包来用。</p>

<p>安装完之后，除了将bin目录加入到path中，还要设置更重要的一个环境变量GOPATH。完成之后就可以开始体验Go了。</p>

<h2>GOPATH</h2>

<p>GOPATH为工作目录，也就是我们写Go程序的workspace。</p>

<p>按照约定，通常有以下三个子目录：</p>

<p><strong>src</strong>：存放源代码（比如：.go等）<br/>
<strong>pkg</strong>：编译后生成的文件（比如：.a）<br/>
<strong>bin</strong>：编译后生成的可执行文件（为了方便，可以把此目录加入到 $PATH 变量中）</p>

<!-- more -->


<h2>Go常用命令</h2>

<h3>go build</h3>

<p>用于编译源文件。在包的编译过程中，若有必要，会同时编译与之相关联的包。</p>

<p>该命令会忽略目录下以“_”或“.”开头的go文件。</p>

<h3>go clean</h3>

<p>用于移除当前源码包里面编译生成的文件。这些文件包括：</p>

<p><strong>_obj/</strong>：旧的object目录，由Makefiles遗留<br/>
<strong>_test/</strong>：旧的test目录，由Makefiles遗留<br/>
<strong>_testmain.go</strong>：旧的gotest文件，由Makefiles遗留<br/>
<strong>test.out</strong>：旧的test记录，由Makefiles遗留<br/>
<strong>build.out</strong>：旧的test记录，由Makefiles遗留<br/>
<strong>*.[568ao]</strong>：object文件，由Makefiles遗留</p>

<p><strong>DIR(.exe)</strong>：由go build产生<br/>
<strong>DIR.test(.exe)</strong>：由go test -c产生<br/>
<strong>MAINFILE(.exe)</strong>：由go build MAINFILE.go产生</p>

<h3>go fmt</h3>

<p>用于格式化源代码文件。</p>

<h3>go get</h3>

<p>用于获取远程代码包，目前支持的有BitBucket、GitHub、Google Code和Launchpad。</p>

<p>这个命令在内部实际上分成了两步操作：第一步是下载源码包，第二步是执行go install。</p>

<h3>go install</h3>

<p>这个命令在内部实际上分成了两步操作：第一步是生成结果文件(可执行文件或者.a包)，第二步会把编译好的结果移到 <em>$GOPATH/pkg</em> 或者 <em>$GOPATH/bin</em>。</p>

<h3>go test</h3>

<p>这个命令会自动读取源码目录下面名为<strong>*_test.go</strong>的文件，生成并运行测试用的可执行文件。</p>

<h3>godoc</h3>

<p>查看API文档。</p>

<p>在命令行执行 <code>godoc -http=:&lt;port&gt;</code>，比如 <em>godoc -http=:8080</em>。然后在浏览器中打开127.0.0.1:8080，你将会看到一个golang.org的本地版本，通过它可以查询pkg文档等其它内容。如果你设置了GOPATH，在pkg分类下，不但会列出标准包的文档，还会列出你本地GOPATH中所有项目的相关文档。</p>

<h3>go fix</h3>

<p>用来修复以前老版本的代码到新版本，例如go1之前老版本的代码转化到go1。</p>

<h3>go version</h3>

<p>查看go当前的版本。</p>

<h3>go env</h3>

<p>查看当前go的环境变量。</p>

<h3>go list</h3>

<p>列出当前全部安装的package。</p>

<h3>go run</h3>

<p>编译并运行Go程序。</p>

<p>准备好了开发环境，熟悉了以上常用的命令，就可以开始Go程序的旅程了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PostgreSQL installation on MAC]]></title>
    <link href="http://askcuix.github.io/blog/2013/08/12/postgresql-installation-on-mac/"/>
    <updated>2013-08-12T19:55:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2013/08/12/postgresql-installation-on-mac</id>
    <content type="html"><![CDATA[<ol>
<li><p><strong>Use MacPorts install PostgreSQL server</strong></p>

<pre><code> sudo port install postgresql93-server
</code></pre></li>
<li><p><strong>Create Database Instance</strong></p>

<pre><code> sudo mkdir -p /opt/local/var/db/postgresql93/defaultdb  
 sudo chown postgres:postgres /opt/local/var/db/postgresql93/defaultdb  
 sudo su postgres -c '/opt/local/lib/postgresql93/bin/initdb -D /opt/local/var/db/postgresql93/defaultdb'  
 sudo mkdir -p /opt/local/var/log/postgresql  
 sudo chown postgres:postgres /opt/local/var/log/postgresql  
</code></pre></li>
<li><p><strong>Start Database Server</strong></p>

<pre><code> sudo su postgres -c '/opt/local/lib/postgresql93/bin/postgres -D /opt/local/var/db/postgresql93/defaultdb'  
</code></pre>

<p>or</p>

<pre><code> sudo su postgres -c '/opt/local/lib/postgresql93/bin/pg_ctl -D /opt/local/var/db/postgresql93/defaultdb -l /opt/local/var/log/postgresql/postgres.log start'
</code></pre></li>
<li><p><strong>Set PATH environment variable</strong></p>

<pre><code> export PATH=/opt/local/lib/postgresql93/bin:$PATH
</code></pre>

<p> Make sure you set the PostgreSQL path before /usr/bin to ensure that you are using the latest versions and not the default Apple provided, otherwise will encounter error when execute operation.</p></li>
<li><p><strong>Create User</strong></p>

<pre><code> createuser --superuser Chris -U postgres
</code></pre></li>
<li><p><strong>Create Database</strong></p>

<pre><code> createdb mydb
</code></pre>

<p>If below error encountered, that caused by you use old version PostgreSQL which provide by Apple, change PATH environment variable to solve.</p>

<pre><code>  createdb: could not connect to database postgres: could not connect to server: No such file or directory   
     Is the server running locally and accepting
     connections on Unix domain socket "/var/pgsql_socket/.s.PGSQL.5432"?
</code></pre></li>
<li><p><strong>Accessing Database</strong></p>

<pre><code> psql mydb
</code></pre>

<p><strong>mydb=#</strong> means you are a database superuser, otherwise display <strong>mydb=></strong>.</p></li>
<li><p><strong>Exit psql</strong></p>

<pre><code> mydb=&gt; \q
</code></pre></li>
<li><p><strong>Shutdown Database Server</strong></p>

<pre><code> sudo su postgres -c 'pg_ctl -D /opt/local/var/db/postgresql93/defaultdb -l /opt/local/var/log/postgresql/postgres.log stop'
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scala学习笔记]]></title>
    <link href="http://askcuix.github.io/blog/2013/06/16/the-scala-notes/"/>
    <updated>2013-06-16T22:34:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2013/06/16/the-scala-notes</id>
    <content type="html"><![CDATA[<p>断断续续总算是读完了《Scala程序设计 - Java虚拟机多核编程实战》，习惯了Java中规中矩的语言规范，面对这种灵活的语法，着实有点不知所措，之前学习Python的时候，也有过类似的感受，不过这次学习Scala的感觉更强烈点。这本薄薄的不到两百页的书，硬是让我看了个把月，但也总算是对Scala有了初步的认识。对于这本书，只能算是入门书籍，很多东西都只是提到，但讲的不够详细。下面是学习过程中记下来的一些笔记，之后再对一些重要语法详细了解吧。</p>

<h2>val vs. var</h2>

<p>用val定义的变量是不可变的，用var定义的变量是可变的。在Scala中应尽量使用val以提升不变性。</p>

<h2>遍历</h2>

<p>RichInt中的两个方法to和until都返回一个Range的实例。<br/>
<strong>to()</strong> 产生的范围包含了上界和下界。</p>

<pre><code>i &lt;- 1 to 3
</code></pre>

<p><strong>until()</strong> 产生的范围排除上界。</p>

<pre><code>i &lt;- 1 until 3
</code></pre>

<p><strong>foreach()</strong>属于Range类，以一个函数值作为参数。</p>

<pre><code>(1 to 3).foreach(i =&gt; print(i))
</code></pre>

<p><strong>&lt;-</strong> 左边为定义的val变量，右边为生成器表达式。<br/>
<strong>=></strong> 左边为参数列表，右边为实现。</p>

<!-- more -->


<h2>点和括号</h2>

<p>如果方法有0或1个参数，点和括号是可选的，如果参数多于一个，则必须使用括号，但点仍然是可选的。</p>

<pre><code>a+b  --&gt; a.+(b)
1 to 3 --&gt;  1.to(3)
</code></pre>

<h2>元组</h2>

<p>元组是一个不变的对象序列，可用逗号分隔的值进行创建。如：<em>(&#8220;a&#8221;, &#8220;b&#8221;, &#8220;c&#8221;)</em></p>

<p>元组元素可以同时赋给多个var或val。如：<em>val (name, age, sex) = getPerson()</em></p>

<p>将元组赋给数量不一致的变量会出现异常，可以通过<strong>._<seq></strong>来访问单个元素。如：</p>

<pre><code>val info = getPerson();
print(info._1) //first element
print(info._2) //second element
</code></pre>

<h2>字符串</h2>

<p>三个双引号之间的字符串可作为多行字符串。如：<em>&#8221;&#8221;&#8220;multiple line string&#8221;&#8220;&#8221;</em><br/>
多行字符串中允许嵌入双引号，多行字符串会保留字符串的原有格式。<br/>
stripMargin()可用于去除先导符前所有的空白或控制字符，默认先导符为“|”。</p>

<h2>类</h2>

<p>在Scala里，类、字段和方法默认是<strong>public</strong>，无需显示声明。</p>

<p><strong>protected</strong>类只可以由子类访问，且子类只可以访问本类的protected成员。</p>

<p><strong>return</strong>是可选的，方法调用会自动返回最后求值的表达式。若使用了return，则必须显示定义返回类型。</p>

<p>如果用&#8221;<strong>=</strong>&#8220;定义方法，Scala可推演返回类型，否则该方法返回类型为void。</p>

<p>分号是可选的，如果在一行内放置多条语句，可以用分号进行分隔。</p>

<p>方法若没有参数，可以省略方法定义中的括号。若构造函数没有参数，new对象后面的括号也可以省略。</p>

<p>给字段加上<strong>@scala.reflect.BeanProperty</strong>注解，即可以生成JavaBean风格的getter/setter。</p>

<p>Scala默认会导入两个包：<strong>java.lang</strong>和<strong>scala</strong>，和一个对象：<strong>scala.Predef</strong>。</p>

<p>赋值结果是Unit类型，因此不可以多重赋值。如：</p>

<pre><code>a = b  // return Unit, not a
a = b = c // throw error: type mismatch, found Unit, require Int
</code></pre>

<p><strong>==</strong>对所有类型都是基于值的比较，而非引用的比较。<strong>eq()</strong>用于引用的比较。</p>

<p>变量赋值时的“<strong>_</strong>”代表该变量类型的默认值：Int为<em>0</em>，Double为<em>0.0</em>，引用类型为<em>null</em>。</p>

<p>import语句里的“<strong>_</strong>”等价于Java中的“<strong>*</strong>”。如果“_”是跟在类名后，则导入类的所有成员，等价于Java中的static import。</p>

<p>主构造函数放在类定义中，若参数声明为val，则定义为private final类型；若参数声明为var，则定义为private类型；若参数既不是val，也不是var，则创建一个private字段以及private的getter/setter，就不能在类的外部访问该参数。</p>

<p>除主构造函数外，还可以通过<strong>this()</strong>定义两个或多个副构造函数。副构造函数的第一条语句必须是调用主构造函数，或调用另外一个副构造函数。如：</p>

<pre><code>class Person(val firstName: String, val lastName: String) {
    private var gender: String = _


    def this (firstName: String, lastName: String, sex: String) {
         this (firstName, lastName)
         gender = sex
    }
}
</code></pre>

<p>类里定义的var字段会映射为一个private字段，并提供对应的getter/setter，字段上附加的访问权限会加到访问方法getter/setter上。</p>

<p>类继承时，重写方法必须使用<strong>override</strong>关键字，只有主构造函数才能通过override关键字往基类构造函数中传参数。如：</p>

<pre><code>class Vehicle(val id: Int, val year: Int){
    override def toString() : String = "ID: " + id + " Year: " + year
}

class Car(override val id: Int, override val year: Int, var fuelLevel: Int) extends Vehicle(id, year) {
    override def toString() : String = super.toString() + " Fuel Level: " + fuelLevel
}
</code></pre>

<p>创建单例对象要用<strong>object</strong>关键字，而非class。因为单例对象无法初始化，所以不能给主构造函数传递参数。</p>

<pre><code>class Marker(val color: String){
    override def toString() : String = "maker color " + color
}

object MarkerFactory {
   private val markers = Map(
       "red" -&gt; new Marker("red")
   )

   def getMarker(color: String) = if (markers.contains(color)) markers(color) else null
}
</code></pre>

<p>上例中依然可以跳过MarkerFactory，直接创建Marker实例。</p>

<p>在Scala中可以创建一个关联到类上的单例，单例同类共享相同的名字，称为<strong>伴生对象</strong>，对应的类称为<strong>伴生类</strong>。类和伴生对象之间可以互相访问彼此的private字段和方法，可以把类的构造函数标记为private，这样就只可以通过伴生对象获取实例。每个类都可以有伴生对象，它们跟伴生类写在同一个文件中。如：</p>

<pre><code>class Marker private (val color: String){
    override def toString() : String = "maker color " + color
}

object Marker {
   private val markers = Map(
       "red" -&gt; new Marker("red")
   )

   def getMarker(color: String) = if (markers.contains(color)) markers(color) else null
}
</code></pre>

<p>Scala中没有静态字段和静态方法，伴生对象中的字段和方法可作为替代实现。</p>

<p>将创建伴生类的实例方法命名为<strong>apply()</strong>，可以更加容易获取实例，这是Scala提供的语法糖。在上例中需要通过 <em>Marker getMarker &#8220;red&#8221;</em> 来获取，若将getMarker改名为apply，则可以直接通过<em>Marker(&#8220;red&#8221;)</em>来获取。</p>

<pre><code>def apply(color: String) = if (markers.contains(color)) markers(color) else null
</code></pre>

<h3>Nothing</h3>

<p>Nothing是所有类的子类。</p>

<h3>Any</h3>

<p>Any是所有类的父类。Any的直接子类是AnyVal和AnyRef，AnyVal是所有可以映射为Java基本类型的类的父类，AnyRef是所有引用类型的父类，可直接映射为Java的Object。</p>

<h3>Option</h3>

<p>用于强制检查实例是否存在。getOrElse()可处理结果不存在的情况。</p>

<h2>可变参数(vararg)</h2>

<p>方法参数在类型之后使用“*”，则标识该参数为可变数目实参。可变参数会当作数组处理，但不可传入数组作为实参。若相使用数组中的值作为可变实参，可以使用“<strong>_*</strong>”展开数组。如：</p>

<pre><code>def max(values: Int*) = values.foldLeft(values(0)) { Math.max }
val numbers = Array(2, 4, 3, 7, 6)
println(max(numbers: _*))
</code></pre>

<h2>参数化类型(Parameterized Type)</h2>

<p>Scala使用“<strong>&lt;:</strong>”来定义参数化类型。如 <em>T&lt;:Pet</em> 表示T为Pet的子类。也可以使用“<strong>>:</strong>”，如 <em>T>:Dog</em> 表示T为Dog的父类。</p>

<pre><code>def playWithPets[T &lt;: Pet](pets: Array[T]) = println("……….")
</code></pre>

<p>参数化类型使用“<strong>+T</strong>”表示允许协变，即可接收某个类型或其父类。</p>

<p>参数化类型使用”<strong>-T</strong>“表示允许逆变，即可接收某个类型或其子类。</p>

<h2>Curry化</h2>

<p>将函数从接收多个参数转变为接收多个参数列表，以减少传递函数值。如：</p>

<p>原函数：</p>

<pre><code>def foo(a: Int, b: Int, operation: (Int, Int) =&gt; Int) ： Int = {}
</code></pre>

<p>Curry化：</p>

<pre><code>def foo(a: Int)(b: Int)(operation: (Int, Int) =&gt; Int) : Int = {}
</code></pre>

<p>调用如下，函数值不需要以参数的形式写在括号中了，这种形式更优雅。</p>

<pre><code>val sum = foo(1)(2) { (c, d) =&gt; c + d}
</code></pre>

<h2>Trait</h2>

<p>Trait里定义和初始化的val和var会在混入trait的类的内部得到实现。如果类没有继承其它类，则可以使用<strong>extends</strong>关键字混入trait；如果类已继承了其它类，则可以使用<strong>with</strong>关键字混入一个或多个trait。</p>

<pre><code>trait Friend {
    val name: String
    def listen() = println("Your friend " + name + " is listening")
}

class Human(val name: String) extends Friend

class Dog(val name: String) extends Animal with Friend
</code></pre>

<p>Trait会被编译成Java的接口，还有对应的实现类，里面包含了trait已实现的方法。</p>

<p>Trait需要混入类实现未初始化的变量和值，trait的构造器不能有任何参数。</p>

<p>Trait也可以在实例中进行混入。如：</p>

<pre><code>class Cat(val name: String) extends Animal

val snowy = new Cat("Snowy") with Friend
</code></pre>

<p>当Trait用于装饰对象时，trait只能混入继承自trait父类的类。在trait里，super并不是对基类的调用，而是对其左边混入的trait的调用，如果这个trait已经是最左的trait，则调用就会解析成混入这个trait的类的方法。</p>

<pre><code>abstract class Check {
    def check() : String = "Checked Details…..."
}

trait CreditCheck extends Check {
    override def check() : String = "Checked Credit……" + super.check()
}

trait EmploymentCheck extends Check {
    override def check() : String = "Checked Employment….." + super.check()
}

val emplomentApp = new Check with EmploymentCheck with CreditCheck
println(emplomentApp check)
</code></pre>

<p>打印结果：</p>

<p><em>Checked Credit……Checked Employment….Checked Details……</em></p>

<p>若trait的基类的方法是抽象的，则trait在继承这个类时，需要将该方法声明为abstract override。这个方法的最终实现由混入这个trait的类提供。</p>

<pre><code>abstract class Writer {
    def writeMessage(message: String)
}

trait UpperCaseWriter extends Writer {
    abstract override def writeMessage(message: String) = super.writeMessage(message.toUpperCase)
}

class StringWriterDelegate extends Writer {
    val writer = new java.io.StringWriter

    def writeMessage(message: String) = writer.write(message)
    override def toString() : String = writer.toString 
}

val writerTest = new StringWriterDelegate with UpperCaseWriter
writerTest writeMessage "String writer test"
println(writerTest)
</code></pre>

<p>打印结果：</p>

<p><em>STRING WRITER TEST</em></p>

<h2>隐式转换</h2>

<p>若需转换数据类型，可定义一个转换方法，并将该方法标记为implicit，该方法需要在变量使用的当前范围内可见（通过当前import可见，或位于当前文件）。</p>

<p>在Predef对象中，Scala已经定义了一些隐式转换，且默认导入它们。Scala一次最多应用一个隐式转换。</p>

<h2>集合类</h2>

<p>Scala的集合类包括：<strong>List</strong>, <strong>Set</strong>和<strong>Map</strong>，除了List外，其它两种集合同时提供了可变和不可变的两个版本，默认使用不可变的集合类。Predef对象为集合类提供的别名指向不可变的实现。</p>

<p>可变版本：<em>scala.collection.mutable</em><br/>
不可变版本：<em>scala.collection.immutable</em></p>

<p>若需要修改集合且对集合的所有操作都在一个线程里，则可以选择可变集合类。</p>

<p><strong>_</strong>：用于表示遍历集合时的每个元素。</p>

<h3>Set</h3>

<p><strong>filter()</strong>：用于过滤Set中的数据。<br/>
<strong>mkString()</strong>：为Set中的每个元素创建了字符串，然后用参数字符串将结果连接起来。与apache common-lang中StringUtils的join方法作用相同。<br/>
<strong>++()</strong>：合并两个Set成一个新的Set。<br/>
<strong>**()</strong>：执行交集运算。<br/>
<strong>map()</strong>：对每个元素应用给定的函数值，将结果收集到一个新的Set中。<br/>
<strong>toArray()</strong>：将Set中的元素复制到数组中，以通过索引来访问Set中的元素。<br/>
<strong>foreach()</strong>：迭代Set中的元素。</p>

<h3>Map</h3>

<p>key与value之间使用<strong>-></strong>。如：<em>val feeds = Map(&#8220;Scala&#8221; -> &#8220;www.scala-lang.org&#8221;)</em></p>

<p><strong>filterKeys()</strong>：对Key进行过滤。<br/>
<strong>filter()</strong>：对Key和Value进行过滤。提供给filter()的函数值接收一个(key, value)元组。如：</p>

<pre><code>val result = feeds filter { element =&gt; 
    val (key, value) = element 
    (key startsWith "S") &amp;&amp; (value contains "lang") 
}
</code></pre>

<p><strong>get()</strong>：用给定的Key获取Value。由于给定的Key可能没有对应的Value，所以该方法的返回类型是Option[T]，结果可能是Some[T]或None，T为Value的类型。<br/>
<strong>apply()</strong>：对类或对象使用括号时，即调用该方法。用于获取给定Key对应的Value，若没有对应的Value，则抛出异常，应将该方法放在try-catch中。<br/>
<strong>update()</strong>：更新Map，并返回一个新的Map。有一种简写的方式：X() = b，等价于X.update(b)，若参数多于一个，则将最后一个参数之外的所有参数放在括号里，X(a) = b 等价于X.update(a, b)。也可以将Map定义为可变容器scala.collection.mutable.Map，则可以直接更新。</p>

<h3>List</h3>

<p>List只有不可变实现。</p>

<p><strong>head()</strong>：可快速访问List的第一个元素。<br/>
<strong>tail()</strong>：用于访问第一个元素之外的其它元素。访问最后一个元素需要遍历List，因此相比较head()，该操作的代价较大。<br/>
<strong>::()</strong>：将元素添加在第一个元素之前。a :: list，即在list前添加a。该方法的完整表示：<em>list.::(a)</em>。<br/>
<strong>:::()</strong>：将一个list附加到另一个list之前。<em>list ::: listA</em>，即在listA前添加list。由于List是不可变的，所以这两个List都不会改变，会创建一个新的List并返回。将一个元素或List添加到另一个List的后面，实际上是调用后面那个List的前缀运算符，由于访问List的头元素比遍历到最后一个元素快的多，因此这种方式的性能会更好。<br/>
<strong>filter()</strong>：对List进行过滤。<br/>
<strong>forall()</strong>：检查List中的元素是否都满足指定的条件。<br/>
<strong>exists()</strong>：检查List中是否存在满足指定条件的元素。<br/>
<strong>map()</strong>：对每个元素应用给定的函数值，将结果收集到一个新的List中。 <br/>
<strong>mkString()</strong>：将List中的元素用参数字符串连接起来。与apache common-lang中StringUtils的join方法作用相同。<br/>
<strong>foldLeft()</strong>：从List的最左端开始为每个元素调用给定的函数值。它会传递两个参数给函数值，第一个参数是对之前元素执行函数值的部分结果，初始值为方法的参数，第二个参数是List的元素。该方法的另一种表示：<strong>/:()</strong>。</p>

<pre><code>val total = feeds.foldLeft(0) { (total, feed) =&gt; total + feed.length }
</code></pre>

<p>等价于</p>

<pre><code>val total = (0 /: feeds) { (total, feed) =&gt; total + feed.length }
</code></pre>

<p><strong>foldRight()</strong>：与foldLeft()的操作相同，但是从List的最右端开始。该方法的另一种表示：<strong>\:()</strong>。</p>

<h2>case表达式</h2>

<p>case表达式通常与match一起使用做模式匹配。case会按照顺序自上而下进行比较。</p>

<p><strong>_</strong>用作通配符，在所有指定的case都不匹配的情况下，作为默认处理，否则会抛出MatchError异常。</p>

<p><strong>_*</strong>用作匹配List时，除去指定元素之外的所有元素。若需要引用这些元素，可以用@放在_*和变量名之间，如：</p>

<pre><code>case List("apple", "orange", otherFruits @ _*) =&gt; println("apples, oranges, and " + otherFruits)
</code></pre>

<p>case语句可以根据类型进行匹配，还可以使用guard语句，用if从句表示。</p>

<pre><code>def process(input: Any) {
    input match {
         case (a: Int, b: Int) =&gt; print("Processing (int, int)…..")
         case (a: Double, b: Double) =&gt; print("Processing (double, double)…..")
         case msg : Int if (msg &gt; 1000) =&gt; print("Processing int &gt; 1000")
         case msg : Int =&gt; print("Processing int…..")
         case _ =&gt; printf("Can't handle %s… ", input)
    }
}
</code></pre>

<p>case表达式中，模式变量要以小写字母开头，常量要以大写字母开头，否则无法通过编译。</p>

<p><strong>sealed abstract</strong>用于告知Scala除该文件中已有的类之外，不会再有其它的类作为case类。若case表达式没有包含所有的case类，则会在编译时遇到warning。</p>

<p>case类若没有参数，在调用case表达式的方式时，也需要使用括号。否则参数就不是case类的实例，而是它的伴生对象。</p>

<p>定义Extractor可以在case表达式中匹配任意模式。unapply()方法用于接收要匹配的值。Extractor方法中的参数并不是传入的实参，而是用于接收从方法中返回的值。Extractor方法中的参数还可以引用另外一个Extractor方法用以验证返回的值，在参数和调用的Extractor方法之间使用@符合。</p>

<h2>正则表达式</h2>

<p>使用<em>scala.util.matching</em>包中的<strong>Regex</strong>类的实例进行匹配。</p>

<p>String的<strong>r()</strong>方法会将String转换成RichString，然后调用该方法并返回Regex实例。</p>

<p>正则表达式可直接在case表达式中作为Extractor使用。正则表达式中每个放在括号里的匹配都展开到一个模式变量中，如：<em>&#8220;(S|s)cala&#8221;.r</em>的unapply()方法会返回Option[String]，<em>&#8220;(S|s)(cala)&#8221;.r</em>的unapply()方法会返回Option[String, String]。</p>

<p><strong>findFirstIn()</strong>：用于查找第一个正则表达式的匹配。<br/>
<strong>findAllIn()</strong>：用于查找正则表达式的所有匹配，并返回List结果。<br/>
<strong>replaceFirstIn()</strong>：用于替换第一个正则表达式的匹配。<br/>
<strong>replaceAllIn()</strong>：用于替换所有正则表达式的匹配。</p>

<h2>actor模型</h2>

<p>actor提供了一种基于事件的轻量级线程。使用<em>scala.actors.Actor</em>伴生对象的<strong>actor()</strong>方法就可以创建一个actor。它接受一个函数值/闭包做参数，一创建好就开始运行。用<strong>!()</strong>方法给actor发消息，用<strong>reveive()</strong>方法从actor接收消息，通常用模式匹配处理接收到的消息。</p>

<p>Scala的Actor是个trait，混入Actor的类必须实现<strong>act()</strong>。start()方法用于启动actor并调用act()方法，没启动之前给actor发送的消息会进入队列。exit()方法用于停止actor，该方法会抛出异常，以终止当前线程的执行。</p>

<p>如果无需控制何时启动actor，则可以使用actor()方法创建actor。在actor中将消息委托给另一个actor，可以并发的处理多个请求。</p>

<p>receive()会造成程序阻塞，指导收到应答为止。receiveWithin()方法接收一个timeout参数，若超时时限内未收到消息，receiveWithin()会收到一个TIMEOUT消息。</p>

<p>使用<strong>SingleThreadedScheduler</strong>可以让Scala在主线程里运行actor，通过设置 <em>Scheduler.impl = new SingleThreadedScheduler</em>，就可以控制整个应用的actor调度策略。通过继承Actor trait，并改写scheduler()方法，可以控制线程是否运行在主线程中。</p>

<h2>与Java互操作</h2>

<p>若要在编译过的Scala或Java代码里使用Scala类，则必须编译Scala文件。</p>

<p>若Java代码中的方法或字段的名字与Scala的关键字有冲突，在调用时会导致Scala编译器死掉。可将冲突的变量名或方法名放在反引号中，以避免该问题。</p>

<p>Java暂不支持闭包，因此若Scala要提供给Java使用，则应避免使用闭包，或同时提供普通函数。</p>

<p>trait若没有方法实现，则可在Java中当作接口使用；若trait中有方法实现，则只可以在Java中持有该引用。</p>

<p>Scala的单例对象，在Java中可以像有static方法的Java类一样使用。</p>

<p>Scala会为同名类的伴生对象创建两个类，若类名为Buddy，则一个伴生类Buddy，和一个伴生对象类Buddy$。在Java中访问伴生类可以直接使用类的名字，访问伴生对象则需要使用MODULE$，如Buddy$.MODULE$。</p>

<p>Scala不支持throws，若Java中继承的Scala方法会抛出异常，就需要在Scala的方法前定义注解@throws。</p>

<h2>Resources</h2>

<p>IBM developerWorks Scala 指南：<a href="http://www.ibm.com/developerworks/cn/java/j-scala/">http://www.ibm.com/developerworks/cn/java/j-scala/</a><br/>
Programming Scala：<a href="http://ofps.oreilly.com/titles/9780596155957/">http://ofps.oreilly.com/titles/9780596155957/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Redis Introduction]]></title>
    <link href="http://askcuix.github.io/blog/2013/06/13/the-redis-introduction/"/>
    <updated>2013-06-13T23:45:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2013/06/13/the-redis-introduction</id>
    <content type="html"><![CDATA[<p>Redis是<strong>RE</strong>mote <strong>DI</strong>ctionary <strong>S</strong>erver的缩写，它采用了单请求处理线程的架构，避免了管理并发的复杂问题，也简化了实现，但同时也带来CPU的瓶颈，当单线程被阻塞时整个Redis都会停止响应。</p>

<h2>Redis Key</h2>

<p>Key不能太长，推荐的格式为：<em>&lt;object type>:&lt;id>:&lt;field></em>，用“<strong>:</strong>”分隔域，用“<strong>.</strong>”作为单词间的连接。</p>

<p>KEYS命令可返回匹配指定模式的key，模式支持通配符，具体可参考：<a href="http://redis.readthedocs.org/en/latest/key/keys.html">http://redis.readthedocs.org/en/latest/key/keys.html</a></p>

<p>SORT命令可对集合按数字或字母顺序排序后返回或另存为list，还可以关联到外部key等。可参考：<a href="http://redis.readthedocs.org/en/latest/key/sort.html">http://redis.readthedocs.org/en/latest/key/sort.html</a></p>

<p>Key超时操作常用的命令：<a href="http://redis.readthedocs.org/en/latest/key/expire.html">EXPIRE</a>、<a href="http://redis.readthedocs.org/en/latest/key/expireat.html">EXPIREAT</a>、<a href="http://redis.readthedocs.org/en/latest/key/persist.html">PERSIST</a>、<a href="http://redis.readthedocs.org/en/latest/key/ttl.html">TTL</a>。</p>

<p>其它关于Key的常用命令：<a href="http://redis.readthedocs.org/en/latest/key/exists.html">EXISTS</a>、<a href="http://redis.readthedocs.org/en/latest/key/del.html">DEL</a>、<a href="http://redis.readthedocs.org/en/latest/key/randomkey.html">RANDOMKEY</a>、<a href="http://redis.readthedocs.org/en/latest/key/rename.html">RENAME</a>、<a href="http://redis.readthedocs.org/en/latest/key/renamenx.html">RENAMENX</a>、<a href="http://redis.readthedocs.org/en/latest/key/type.html">TYPE</a>。</p>

<!-- more -->


<h2>Redis Value的数据结构</h2>

<h3>String</h3>

<p>可以是任何种类的字符串（包括二进制数据），长度不能超过1GB。</p>

<p>除了最基本的GET/SET，Redis还提供了一些简便的指令。</p>

<p><a href="http://redis.readthedocs.org/en/latest/string/incr.html">INCR</a>/<a href="http://redis.readthedocs.org/en/latest/string/decr.html">DECR</a>/<a href="http://redis.readthedocs.org/en/latest/string/incrby.html">INCRBY</a>/<a href="http://redis.readthedocs.org/en/latest/string/incrbyfloat.html">INCRBYFLOAT</a>/<a href="http://redis.readthedocs.org/en/latest/string/decrby.html">DECRBY</a>：针对数字类型的字符串。若key不存在时创建key并设值为0。INCRBYFLOAT专门针对float类型的值，使用负数即可实现DECR的效果。</p>

<p><a href="http://redis.readthedocs.org/en/latest/string/setex.html">SETEX</a>：即Set + Expire。</p>

<p><a href="http://redis.readthedocs.org/en/latest/string/setnx.html">SETNX</a>：即SET if Not eXists。</p>

<p><a href="http://redis.readthedocs.org/en/latest/string/getset.html">GETSET</a>：设置新值，并返回旧值。</p>

<p><a href="http://redis.readthedocs.org/en/latest/string/mget.html">MGET</a>/<a href="http://redis.readthedocs.org/en/latest/string/mset.html">MSET</a>/<a href="http://redis.readthedocs.org/en/latest/string/msetnx.html">MSETNX</a>：GET/SET/SETNX的批量操作。</p>

<p><a href="http://redis.readthedocs.org/en/latest/string/getbit.html">GETBIT</a>/<a href="http://redis.readthedocs.org/en/latest/string/setbit.html">SETBIT</a>/<a href="http://redis.readthedocs.org/en/latest/string/bitop.html">BITOP</a>/<a href="http://redis.readthedocs.org/en/latest/string/bitcount.html">BITCOUNT</a>：Redis BitMap的用法，使用场景可参考：<a href="http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps/">http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps/</a>。</p>

<p><a href="http://redis.readthedocs.org/en/latest/string/append.html">APPEND</a>/<a href="http://redis.readthedocs.org/en/latest/string/setrange.html">SETRANGE</a>/<a href="http://redis.readthedocs.org/en/latest/string/getrange.html">GETRANGE</a>/<a href="http://redis.readthedocs.org/en/latest/string/strlen.html">STRLEN</a>：对字符串进行扩展、替换、截取和取长度，只适用于特定数据格式的字符串。</p>

<h3>Hash</h3>

<p>Key-HashMap结构，可以一次set，get多个属性。相比JSON格式的字符串，可以只读取/更新对象的某些属性，不用取回所有的属性，改完再写回去。</p>

<p>可以通过该数据结构建立索引。比如User对象，通常都会使用id或name来查询，这样在插入User对象时：<em>set user:101 {&#8220;id&#8221;:101,&#8221;name&#8221;:&#8221;admin&#8221;}</em>， 同时再插入一条hash结构的索引：<em>hset user:index:name admin 101</em>。按name查询的时候，使用：<em>hget user:index:name admin</em> 就能取出对应的id。</p>

<h3>List</h3>

<p>List是一个双向链表，基于linked list，支持双向的Pop/Push，一般从左端Push，右端Pop。在左端或右端添加一个元素的复杂度是一样的。</p>

<p>List的下标从0开始，从左到右计算，下标为负数时则从右到左。</p>

<p>常用的命令：</p>

<p><a href="http://redis.readthedocs.org/en/latest/list/lrem.html">LREM</a>：按值删除元素。<br/>
<a href="http://redis.readthedocs.org/en/latest/list/linsert.html">LINSERT</a>：插在某个值的前后。<br/>
<a href="http://redis.readthedocs.org/en/latest/list/lset.html">LSET</a>：按下标设置元素值。<br/>
<a href="http://redis.readthedocs.org/en/latest/list/lindex.html">LINDEX</a>：按下标返回元素。<br/>
<a href="http://redis.readthedocs.org/en/latest/list/lrange.html">LRANGE</a>：返回列表内一段下标的元素，可用于分页操作。<br/>
<a href="http://redis.readthedocs.org/en/latest/list/ltrim.html">LTRIM</a>：限制List的大小。   <br/>
<a href="http://redis.readthedocs.org/en/latest/list/blpop.html">BLPOP</a>/<a href="http://redis.readthedocs.org/en/latest/list/brpop.html">BRPOP</a>：阻塞版的pop命令，可用于Message Queue，当多个Client并发阻塞等待，有Element入列时谁先被阻塞谁先被服务。</p>

<h3>Set</h3>

<p>用于存储不重复的值，无序。还提供一些交集，并集，差集的集合操作。</p>

<p><a href="http://redis.readthedocs.org/en/latest/set/sadd.html">SADD</a>/<a href="http://redis.readthedocs.org/en/latest/set/srem.html">SREM</a>/<a href="http://redis.readthedocs.org/en/latest/set/sismember.html">SISMEMBER</a>/<a href="http://redis.readthedocs.org/en/latest/set/scard.html">SCARD</a>/<a href="http://redis.readthedocs.org/en/latest/set/smove.html">SMOVE</a>/<a href="http://redis.readthedocs.org/en/latest/set/smembers.html">SMEMBERS</a>：基本操作。
<a href="http://redis.readthedocs.org/en/latest/set/sinter.html">SINTER</a>/<a href="http://redis.readthedocs.org/en/latest/set/sinterstore.html">SINTERSTORE</a>/<a href="http://redis.readthedocs.org/en/latest/set/sunion.html">SUNION</a>/<a href="http://redis.readthedocs.org/en/latest/set/sunionstore.html">SUNIONSTORE</a>/<a href="http://redis.readthedocs.org/en/latest/set/sdiff.html">SDIFF</a>/<a href="http://redis.readthedocs.org/en/latest/set/sdiffstore.html">SDIFFSTORE</a>：集合操作。</p>

<h3>Sorted Set</h3>

<p>有序集合，元素放入集合时要提供该元素的分数。</p>

<p><a href="http://redis.readthedocs.org/en/latest/sorted_set/zrange.html">ZRANGE</a>/<a href="http://redis.readthedocs.org/en/latest/sorted_set/zrevrange.html">ZREVRANGE</a>：按排名的上下限返回元素，正数与倒数。<br/>
<a href="http://redis.readthedocs.org/en/latest/sorted_set/zrangebyscore.html">ZRANGEBYSCORE</a>/<a href="http://redis.readthedocs.org/en/latest/sorted_set/zrevrangebyscore.html">ZREVRANGEBYSCORE</a>：按分数的上下限返回元素，正数与倒数。<br/>
<a href="http://redis.readthedocs.org/en/latest/sorted_set/zremrangebyrank.html">ZREMRANGEBYRANK</a>/<a href="http://redis.readthedocs.org/en/latest/sorted_set/zremrangebyscore.html">ZREMRANGEBYSCORE</a>：按排名/分数的上下限删除元素。<br/>
<a href="http://redis.readthedocs.org/en/latest/sorted_set/zcount.html">ZCOUNT</a>：统计分数上下限之间的元素个数。<br/>
<a href="http://redis.readthedocs.org/en/latest/sorted_set/zrank.html">ZRANK</a>/<a href="http://redis.readthedocs.org/en/latest/sorted_set/zrevrank.html">ZREVRANK</a>：显示某个元素的正倒序的排名。<br/>
<a href="http://redis.readthedocs.org/en/latest/sorted_set/zscore.html">ZSCORE</a>/<a href="http://redis.readthedocs.org/en/latest/sorted_set/zincrby.html">ZINCRBY</a>：显示元素的分数/增加元素的分数。<br/>
<a href="http://redis.readthedocs.org/en/latest/sorted_set/zadd.html">ZADD</a>/<a href="http://redis.readthedocs.org/en/latest/sorted_set/zrem.html">ZREM</a>/<a href="http://redis.readthedocs.org/en/latest/sorted_set/zcard.html">ZCARD</a>/<a href="http://redis.readthedocs.org/en/latest/sorted_set/zinterstore.html">ZINSERTSTORE</a>/<a href="http://redis.readthedocs.org/en/latest/sorted_set/zunionstore.html">ZUNIONSTORE</a>：集合操作，与Set相比，少了IsMember和差集运算。</p>

<h2>事务</h2>

<p>用<strong>MULTI</strong>(Start Transaction)、<strong>EXEC</strong>(Commit)、<strong>DISCARD</strong>(Rollback)实现。 在事务提交前，不会执行任何指令，只会把它们存到一个队列里。此时其他客户端可以对当前数据进行任意的操作。在事务提交时，批量执行所有指令，因为是单线程架构，在执行完事务内所有指令前是不可能再去同时执行其他客户端的请求的。</p>

<p>Redis不保证所有指令同时成功或失败，只有决定是否开始执行全部指令的能力，没有执行到一半进行回滚的能力。</p>

<p><strong>WATCH</strong>命令在事务提交时，如果Key的值已被别的客户端改变，则整个事务队列都不会被执行。</p>

<h2>持久化</h2>

<p>RDB与AOF完全独立运行。只有正确关闭服务器：<em>redis-cli shutdown</em>，才保证写RDB文件以及将AOF文件fsync到磁盘，不会丢失数据。 如果是<em>Ctrl+C</em>，或者 <em>kill -9</em> 就可能丢失。</p>

<h3>RDB</h3>

<p>整个内存的压缩过的Snapshot，可以配置复合的重写触发条件，默认是1分钟内改了1万次，或5分钟内改了10次，或15分钟内改了1次。</p>

<p>先写到临时文件再重命名，这样外部程序对RDB文件的备份和传输过程是安全的。而且即使写新快照的过程中Server被强制关掉了，旧的RDB文件还在。</p>

<p>可配置是否进行压缩，压缩方法是字符串的LZF算法，以及将string形式的数字变回int形式存储。</p>

<h3>AOF</h3>

<p>append only的操作日志，记录所有有效的写操作，格式就是Redis协议的纯文本文件。</p>

<p>如果使用了AOF，重启时只会从AOF文件载入数据，不会再管RDB文件。</p>

<p>RDB不会实时写入数据，而且如果同时使用两者，但服务器重启只会找AOF文件。不建议只使用AOF，因为RDB更适合用于备份数据库，快速重启。</p>

<h2>Windows版本</h2>

<p>Redis本身并未提供Windows版本，微软技术小组采用LibUV成功将Redis移植到了windows平台，这样就方便了应用的本地开发调试。</p>

<p>目前的稳定版是2.6版本，支持Lua脚本：<a href="https://github.com/MSOpenTech/redis">https://github.com/MSOpenTech/redis</a></p>

<p>编译好的可执行文件：<a href="https://github.com/MSOpenTech/redis/tree/2.6/bin/release">https://github.com/MSOpenTech/redis/tree/2.6/bin/release</a></p>

<h2>Resources</h2>

<p>Redis的设计与实现：<a href="http://www.redisbook.com/en/latest/">http://www.redisbook.com/en/latest/</a><br/>
The Little Redis Book：<a href="http://openmymind.net/2012/1/23/The-Little-Redis-Book/">http://openmymind.net/2012/1/23/The-Little-Redis-Book/</a><br/>
Redis 命令参考：<a href="http://redis.readthedocs.org/en/latest/">http://redis.readthedocs.org/en/latest/</a> <br/>
NoSQLFan - Redis资料汇总专题：<a href="http://blog.nosqlfan.com/html/3537.html">http://blog.nosqlfan.com/html/3537.html</a><br/>
Redis响应延迟问题排查：<a href="http://www.oschina.net/translate/redis-latency-problems-troubleshooting">http://www.oschina.net/translate/redis-latency-problems-troubleshooting</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac使用技巧]]></title>
    <link href="http://askcuix.github.io/blog/2013/06/09/the-mac-tips/"/>
    <updated>2013-06-09T15:11:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2013/06/09/the-mac-tips</id>
    <content type="html"><![CDATA[<p>一些常用的Mac使用技巧，记下来以方便查阅。</p>

<h2>文件管理</h2>

<p><strong>删除文件</strong>：command+delete</p>

<p><strong>清空废纸篓(有确认)</strong>：shift+command+delete</p>

<p><strong>清空废纸篓(无确认)</strong>：shift+option+command+delete</p>

<p><strong>打开文件</strong>：command+o</p>

<p><strong>全屏幕截图(图片默认存放在桌面)</strong>：shift+command+3</p>

<p><strong>鼠标选取截图(图片默认存放在桌面)</strong>：shift+command+4</p>

<p><strong>选取文本</strong>：用command+鼠标，可以选中不同位置的文本内容。 用option+鼠标，可以对文本进行块选。</p>

<p><strong>粘贴纯文本</strong>：我们在网页或其他文档上复制文字的时候，会把文字格式一并复制下来，command+v会把文字格式都粘贴过去，如果我们只想粘贴纯文本，可以使用shift+option+command+v。</p>

<p><strong>定位Spotlight搜索结果的文件夹</strong>：用Spotlight搜索的时候，搜到文件时，若需要打开该文件所在的文件夹，只需按住command键，点击文件即可打开Finder，并定位到该文件所在文件夹。</p>

<!-- more -->


<h2>字符输入</h2>

<p><strong>美元$</strong>：shift+4<br/>
<strong>美分¢</strong>：option+4<br/>
<strong>英镑£</strong>：option+3<br/>
<strong>人民币¥</strong>：option+y<br/>
<strong>欧元€</strong>：shift+option+2<br/>
<strong>波折号–</strong>：option+-或shift+option+-<br/>
<strong>省略号…</strong>：option+;<br/>
<strong>约等于≈</strong>：option+x<br/>
<strong>度°</strong>：shift+option+8<br/>
<strong>除号÷</strong>：option+/<br/>
<strong>无穷大∞</strong>：option+5<br/>
<strong>小于等于≤</strong>：option+,<br/>
<strong>大于等于≥</strong>：option+.<br/>
<strong>不等于≠</strong>：option+=<br/>
<strong>圆周率Piπ</strong>：option+p<br/>
<strong>正负±</strong>：shift+option+=<br/>
<strong>平方根√</strong>：option+v<br/>
<strong>总和∑</strong>：option+w<br/>
<strong>商标Trademark™</strong>：option+2<br/>
<strong>注册®</strong>：option+r<br/>
<strong>版权©</strong>：option+g<br/>
<strong>苹果标志</strong>：option+shift+k</p>

<h2>系统管理</h2>

<p><strong>du -sh *</strong>：查看某个目录下各个文件和子目录所占空间大小。</p>

<p><strong>top</strong>：显示目前系统的进程情况、CPU使用情况、内存使用情况、磁盘使用情况和进程的详细列表等信息，输入? 会显示帮助信息，可以自定义top显示的信息，q退出监控界面。</p>

<p><strong>查看电源的详细信息</strong>：按住option键，点击左上角的苹果－系统信息，在打开窗口的左侧栏中找到电源，点击即可查看电源的详细信息，主要的指标包括电池循环计数、状况等信息。</p>

<p><strong>启用F功能键</strong>：打开系统偏好设置-键盘，选中“将 F1、F2 等键用作标准功能键”，启用此选项时，顶部一行按键将用作标准功能键 (F1 - F12)，而不执行音量控制等特殊功能。启用此选项后，若要使用这些按键的特殊功能，请按fn，比如请fn+f8来播放音乐。</p>

<p><strong>执行root权限</strong>：在命令之前增加sudo指令，系统会提示你输入用户密码，执行root权限。</p>

<p><strong>启用root用户</strong>：打开Finder，输入shift+command+g，在前往文件夹中输入：/System/Library/CoreServices，然后在目录中找到目录实用工具并打开，解开左下角的小锁，然后点击顶部编辑菜单，就会看到启用或停用root用户的选项了。然后我们在命令行下执行su -，就可以切换到root目录下，root的默认目录是/var/root。</p>

<h2>日常使用</h2>

<p><strong>调节音量(无“啵啵”声)</strong>：shift+音量调节按钮。</p>

<p><strong>最小音量</strong>：将音量调节减到(F11)静音，然后按静音(F10)调节静音或最小音量。</p>

<p><strong>无确认窗口</strong>：按住option，再点关机、重启、注销时，就不会弹出确认窗口。</p>

<p><strong>选择资料库</strong>：按住option，再打开itunes、iphoto等软件，可以打开选择资料库的对话框。</p>

<p><strong>关闭所有窗口</strong>：command+option+w。</p>

<p><strong>复制文件</strong>：按住option拖拽文件。</p>

<p><strong>创建替身</strong>：按住option+command拖拽文件。</p>

<h2>MAC命令</h2>

<p>显示隐藏文件：</p>

<pre><code>defaults write com.apple.finder AppleShowAllFiles -bool YES
</code></pre>

<p>恢复隐藏文件不可见：</p>

<pre><code>defaults write com.apple.finder AppleShowAllFiles -bool NO
</code></pre>

<p>重启Finder：</p>

<pre><code>killall Finder
</code></pre>

<h2>TextMate</h2>

<p><strong>转换字符为大写</strong>：control+u<br/>
<strong>转换字符为小写</strong>：control+shift+u</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[XML文件比较工具]]></title>
    <link href="http://askcuix.github.io/blog/2013/06/01/the-tool-for-xml-compare/"/>
    <updated>2013-06-01T17:27:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2013/06/01/the-tool-for-xml-compare</id>
    <content type="html"><![CDATA[<p>最近公司的新产品准备上线，因为涉及到多个系统之间的集成，所以要做几轮的模拟测试，以保证系统间的稳定运行以及数据的准确性。对于其中一个Batch Job，我们需要生成多种XML给其它系统使用，这个Batch并不是全新的，在之前的版本就有，但是这次数据模型有变动，一些业务逻辑也有少许变动，但期望生成的数据是一样的，所以就需要比较两个版本的系统所生成的XML。</p>

<p>现在真是越来越不喜欢XML，超过30M的文件，基本就不可能用NotePad++打开了（与我的机器配置太差也有关系）。通常对于一些小的文件，还可以用Beyond Compare之类的比较工具，而我们Batch生成的XML文件可能会超过100M，那就不可能通过一些桌面软件去做比较了，而且数量太大，肉眼比较的准确性也不能保证。<!-- more -->这些XML文件中主要是金融产品信息，由于在生成文件的时候并没有做排序，因此每次生成的文件中，产品的顺序可能也是不同的，这样就更难用比较工具了。</p>

<p>对于这种情况，只能自己去写个比较工具了，在网上找了一下，也没找到满足要求的，现在代码已经完成，放在<a href="https://github.com/askcuix/xml-compare-tool">GitHub</a>,可以生成比较详细的统计信息，如XML中的record数量，不同record的数量，不相同的field，处理时间等。在我那台破机器上，比较两个150M的文件，可以在两分钟内完成。</p>

<p>具体的用法可项目的主页上已经有描述了，这里简单说下实现的思路，因为实现的比较匆忙，有很多考虑不周的地方。实现的步骤如下：</p>

<ol>
<li>通过SAX解析将源文件解析成一个Map，key为产品ID，可以为一个或多个element组合而成，value为该产品所对应的XML内容。</li>
<li>仍然通过SAX解析待比较的文件，每解析出一个产品信息，就从之前的Map中取出相同的产品信息，这时就得到了相同产品的两个版本的内容。如果产品只存在于待比较的文件中，则计入不同record的数量。</li>
<li>使用DOM解析两个XML片段，结果放在两个Map中，key为element的名字，value的element的值。这里需要考虑几种情况：如果element是可选的，则可能只出现在其中一个XML片段中；如果element是重复性的组合元素，则当作一个field。</li>
<li>在比较的过程中，每比较完一个XML片段就删除引用，以达到在内存不够时，可以通过GC释放内存。</li>
<li>当比较结束，第一步产生的Map中若还有产品存在，则为待比较的文件中没有的产品，计入不同record的数量。</li>
<li>统计比较结果，一并写入文件中。</li>
</ol>


<p>暂时未考虑到更好的有效利用内存的方法，对于比较重复性的element，现在是通过配置来识别，一直在纠结要不要通过解析XSD来实现，但这种方式既增加了代码的复杂性，也很难去处理不同级别的重复性元素，比如root element是productList，下一级就是重复性的元素product,对于这种情况，是不应当视为重复性元素来处理的。</p>

<p>改进还要继续，提供给更多有相似需求的人使用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git常用命令]]></title>
    <link href="http://askcuix.github.io/blog/2013/05/27/the-git-command/"/>
    <updated>2013-05-27T23:35:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2013/05/27/the-git-command</id>
    <content type="html"><![CDATA[<h2>Git配置</h2>

<p><strong>/etc/gitconfig</strong>：系统中对所有用户都普遍适用的配置。若使用git config时用 &#8211;system 选项，读写的就是这个文件。 <br/>
<strong>~/.gitconfig</strong>：用户目录下的配置文件只适用于该用户。若使用git config时用 &#8211;global选项，读写的就是这个文件。 <br/>
<strong>.git/config</strong>：这里的配置仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖 /etc/giconfig 中的同名变量。</p>

<h2>文件状态</h2>

<p><strong>untracked</strong>：未加入版本控制管理的文件。<br/>
<strong>tracked</strong>：已纳入版本控制管理的文件。<br/>
<strong>unmodified</strong>：未做过修改，并且已经在版本控制管理中的文件。<br/>
<strong>modified</strong>：做过修改的受版本控制管理的文件。<br/>
<strong>staged</strong>：已放入暂存区的文件。untracked或者modified的文件，执行过git add后，就进入了暂存区。</p>

<!-- more -->


<h2>.gitignore格式规范</h2>

<ol>
<li>所有空行或者以注释符号 # 开头的行都会被Git忽略。</li>
<li>可以使用标准的glob模式匹配。glob模式是指shell所使用的简化了的正则表达式。星号（*）匹配零个或多个任意字符；[abc]匹配任何一个列在方括号中的字符；问号（?）只匹配一个任意字符；[a-z]匹配所有在这两个字符范围内的字符。</li>
<li>匹配模式最后跟反斜杠（/）说明要忽略的是目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</li>
</ol>


<h2>图形化工具</h2>

<p>在项目工作目录中输入 <strong>gitk</strong> 命令后，图形化工具就会启动。</p>

<h2>HEAD</h2>

<p>HEAD是一个指向正在工作中的本地分支的指针。</p>

<h2>Git命令</h2>

<p><strong>git init</strong><br/>
将当前目录加入Git管理。</p>

<p><strong>git clone [url]</strong><br/>
克隆仓库。</p>

<p><strong>git clone [url] [name]</strong><br/>
自定义克隆仓库的名称。<br/>
<em>&#8211;bare</em> 把现有仓库导出未裸仓库，name以 .git 结尾。</p>

<p><strong>git status</strong><br/>
查看当前文件状态。</p>

<p><strong>git add [file/dir]</strong><br/>
跟踪新文件或目录。如果是目录的话，将递归跟踪该目录下的所有文件。该操作会将目标文件放入暂存区，同时untracked的文件标记为需要track，还能用于合并时把有冲突的文件标记为已解决状态。在执行了git add操作后，又对文件做出了修改，需要再次执行git add操作，否则执行提交操作时，只会将修改前的版本提交到仓库中。</p>

<p><strong>git diff</strong><br/>
查看尚未暂存的文件的变化内容。此命令比较的是工作目录中当前文件和暂存区域快照之间的差异。<br/>
<em>&#8211;cached</em> / <em>&#8211;staged</em> 查看已经暂存起来的文件和上次提交时的快照之间的差异。</p>

<p><strong>git commit</strong><br/>
提交暂存区域的更新。没有提交到暂存区的文件，提交时不会包含。这种无参数的提交命令会启动文本编辑器以便输入本次提交的说明。 <br/>
<em>-m <comments></em> 可以直接执行提交操作。<br/>
<em>-a</em> Git会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过git add步骤。<br/>
<em>&#8211;amend</em> 撤销刚才的提交操作，使用当前的暂存区域快照重新提交。</p>

<p><strong>git reset HEAD [file]</strong><br/>
取消已经暂存的文件。</p>

<p><strong>git checkout &#8211; [file]</strong><br/>
取消对未放入暂存区的文件的修改。</p>

<p><strong>git rm [file/dir]</strong><br/>
从已跟踪文件清单中移除文件，并从工作目录中删除指定的文件，才不会出现在未跟踪的文件清单中。<br/>
<em>-f</em>  强制删除已经放到暂存区域并且做过修改的文件。<br/>
<em>&#8211;cached</em>  将文件从Git仓库中删除（即移除跟踪），但仍然保留在当前工作目录中。<br/>
在路径中加上 \* 会递归删除当前目录及子目录中所有匹配的文件。</p>

<p><strong>git mv [from_file] [to_file]</strong><br/>
重命名操作。<br/>
该命令相当于运行了下面三条命令：</p>

<pre><code>$ mv [from_file] [to_file]
$ git rm [from_file]
$ git add [to_file]
</code></pre>

<p><strong>git remote</strong><br/>
查看当前的远程库。在克隆完某个项目后，至少可以看到一个名为origin的远程库。<br/>
<em>-v</em> 显示对应的克隆地址。</p>

<p><strong>git remote add [shortname] [url]</strong><br/>
提交一个新的远程仓库。</p>

<p><strong>git fetch [remote-name]</strong><br/>
从远程仓库抓取数据到本地。fetch命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支。</p>

<p><strong>git pull</strong><br/>
如果设置了某个分支用于跟踪某个远端仓库的分支，可以使用git pull命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中的当前分支。git clone命令本质上就是自动创建了本地的master分支用于跟踪远程仓库中的master分支。</p>

<p><strong>git push [remote-name] [branch-name]</strong><br/>
将本地仓库中的数据推送到远程仓库。</p>

<p><strong>git push [remote-name] :[branch-name]</strong><br/>
删除远程分支。</p>

<p><strong>git remote show [remote-name]</strong><br/>
查看远程仓库的详细信息。</p>

<p><strong>git remote rename [origin-shortname] [shortname]</strong><br/>
修改远程仓库在本地的简短名称。</p>

<p><strong>git remote rm [shortname]</strong><br/>
删除对应的远端仓库。</p>

<p><strong>git tag</strong><br/>
列出现有的标签。<br/>
<em>-l <pattern></em> 用特定的搜索模式列出符合提交的标签。 <br/>
<em>&lt;tagname></em> 创建一个轻量级标签。轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。<br/>
<em>-a <tagname></em> 创建一个含附注类型的标签。附注标签实际上是存储在仓库中的一个独立对象，它有自身的校验和信息。 <br/>
<em>-m</em> 指定对应的标签说明。</p>

<p><strong>git show [tagname]</strong><br/>
查看相应标签的版本信息。</p>

<p><strong>git push origin [tagname]</strong><br/>
默认情况下，git push并不会把标签传送到远端服务器上，只用通过显示命令才能分享标签到远端仓库。<br/>
<em>&#8211;tags</em> 一次推送所有本地新增的标签上去。</p>

<p><strong>git branch [branchname]</strong><br/>
创建分支。如果没指定branchname，则列出所有的分支，并标明当前所在分支。<br/>
<em>-b</em> 创建分支并切换到该分支。<br/>
<em>-d</em> 删除分支。如果该分支还没并入当前分支，则不允许删除。<br/>
<em>-D</em> 强制删除分支。<br/>
<em>-v</em> 查看各个分支最后一个提交对象的信息。<br/>
<em>&#8211;merge</em> 查看哪些分支已被并入当前分支。 <br/>
<em>&#8211;no-merged</em> 查看哪些分支尚未并入当前分支。</p>

<p><strong>git checkout [branchname]</strong><br/>
切换到其它分支，此时HEAD指向新的分支。</p>

<p><strong>git merge [branchname]</strong><br/>
合并分支到当前分支。<br/>
<em>&#8211;squash</em> 将目标分支上的所有更改全拿来应用到当前分支。<br/>
<em>&#8211;no-commit</em> 告诉Git此时无需自动生成和记录（合并）提交。</p>

<p><strong>git rebase [branchname]</strong><br/>
rebase分支内容到当前分支。<br/>
<em>&#8211;onto</em> 指定新的基底分支。</p>

<p><strong>git log</strong><br/>
查看提交历史。默认会按提交时间列出所有的更新，最近的更新排在最上面。</p>

<pre><code>-[n] 仅显示最近的n条提交。
--since, --after 仅显示指定时间之后的提交。
--until, --before 仅显示指定时间之前的提交。
--author 仅显示指定作者相关的提交。
--committer 仅显示指定提交者相关的提交。
--grep 搜索提交说明中的关键字。如果要得到同时满足这两个选项搜索条件的提交，就必须用 --all-match 选项，否则，满足任意一个条件的提交都会被匹配出来。
-- [path] 显示指定的文件或目录的历史提交。
-p 展开显示每次提交的内容差异。
--stat 显示每次更新的文件修改统计信息。
--shortstat 只显示 --stat 中最后的行数修改提交移除统计。
--name-only 仅在提交信息后显示已修改的文件清单。
--abbrev-commit 仅显示SHA-1的前几个字符，而非所有的40个字符。
--relative-date 使用较短的相对时间显示（比如 “2 weeks ago”）。
--graph 显示ASCII图形表示的分支合并历史。
--pretty 使用其它格式显示历史提交信息。可用的选项包括oneline，short，full，fuller和format（后跟指定格式）。用oneline或format时结合--graph选项，可以看到开头多出一些ASCII字符串表示的简单图形，形象的展示了每个提交所在的分支及其分化衍合情况。oneline将每个提交放在一行显示，这在提交数很大时非常有用。format可以定制要显示的记录格式，这样的输出便于后期提取分析，如：$ git log --pretty=format:"%h - %ar : %s"
</code></pre>

<p>常用的占位符如下：</p>

<pre><code>%H 提交对象（commit）的完整哈希字串
%h 提交对象的简单哈希字串
%T 树对象（tree）的完整哈希字串
%t 树对象的简短哈希字串
%P 父对象（parent）的完整哈希字串
%p 父对象的简短哈希字串
%an 作者（author）的名字
%ae 作者的电子邮件地址
%ad 作者修订日期（可以用 -date 选项定制格式）
%ar 作者修订日期，按多久以前的方式显示
%cn 提交者（committer）的名字
%ce 提交者的电子邮件地址
%cd 提交日期
%cr 提交日期，按多久以前的方式显示
%s 提交说明
</code></pre>

<h2>Tips</h2>

<h3>自动补全</h3>

<p>如果使用的是Bash shell，下载Git的源代码，将<em>contrib/completion/git-completion.bash</em>复制到用户主目录中 <em>cp git-completion.bash ~/.git-completion.bash</em>，并把下面一行内容添加到你的.bashrc文件中：</p>

<pre><code>source ~/.git-completion.bash
</code></pre>

<p>也可以为系统上所有用户都设置默认使用此脚本。Mac上将此脚本复制到<em>/opt/local/etc/bash_completion.d</em>目录中，Linux上则复制到<em>/etc/bash_completion.d</em>目录中。这两处目录中的脚本，都会在Bash启动时自动加载。</p>

<h3>Git命令别名</h3>

<p>可以用git config为命令设置别名，如：</p>

<pre><code>git config --global alias.ci commit
</code></pre>

<h2>Resources</h2>

<p>Pro Git中文版：<a href="http://git-scm.com/book/zh">http://git-scm.com/book/zh</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring NamedParameterJdbcTemplate的内存泄漏问题]]></title>
    <link href="http://askcuix.github.io/blog/2013/05/06/the-memory-leak-problem-of-spring-namedparameterjdbctemplate/"/>
    <updated>2013-05-06T22:36:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2013/05/06/the-memory-leak-problem-of-spring-namedparameterjdbctemplate</id>
    <content type="html"><![CDATA[<p>我们的项目是使用Spring JDBC来操作DB的，通常是直接使用SimpleJdbcTemplate，一直以来也没发现什么问题。今天在做performance test的时候，发现内存增长很快，甚至出现了out of memory。把heap dump拉下来查看后，发现是这次新加的一个service出现了问题，但根源是因为NamedParameterJdbcTemplate中的HashMap导致的。</p>

<p>这里要先说明使用的Spring的版本是2.5.6，在3.0.3中已修复该问题。</p>

<!-- more -->


<p>查看调用的trace是service->SimpleJdbcTemplate->NamedParameterJdbcTemplate。一直没有仔细看过SimpleJdbcTemplate的源码，其实它基本都是通过调用NamedParameterJdbcTemplate来完成操作的。SimpleJdbcTemplate的初始化，其实就是初始化NamedParameterJdbcTemplate。</p>

<figure class='code'><figcaption><span>SimpleJdbcTemplate.java</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>   <span class="kd">public</span> <span class="nf">SimpleJdbcTemplate</span><span class="o">(</span><span class="n">DataSource</span> <span class="n">dataSource</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">namedParameterJdbcOperations</span> <span class="o">=</span> <span class="k">new</span> <span class="n">NamedParameterJdbcTemplate</span><span class="o">(</span><span class="n">dataSource</span><span class="o">);</span>
</span><span class='line'>   <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>   <span class="kd">public</span> <span class="nf">SimpleJdbcTemplate</span><span class="o">(</span><span class="n">JdbcOperations</span> <span class="n">classicJdbcTemplate</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">namedParameterJdbcOperations</span> <span class="o">=</span> <span class="k">new</span> <span class="n">NamedParameterJdbcTemplate</span><span class="o">(</span><span class="n">classicJdbcTemplate</span><span class="o">);</span>
</span><span class='line'>   <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>   <span class="kd">public</span> <span class="nf">SimpleJdbcTemplate</span><span class="o">(</span><span class="n">NamedParameterJdbcOperations</span> <span class="n">namedParameterJdbcTemplate</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">namedParameterJdbcOperations</span> <span class="o">=</span> <span class="n">namedParameterJdbcTemplate</span><span class="o">;</span>
</span><span class='line'>   <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>NamedParameterJdbcTemplate的作用是方便使用命名式的参数，以代替使用SQL中的‘?’。NamedParameterJdbcTemplate会将每次解析过后的SQL放在一个HashMap中，以起到cache的作用，而问题就出现这个Map上。</p>

<figure class='code'><figcaption><span>NamedParameterJdbcTemplate.java</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>   <span class="kd">private</span> <span class="kd">final</span> <span class="n">Map</span> <span class="n">parsedSqlCache</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>   <span class="kd">protected</span> <span class="n">ParsedSql</span> <span class="nf">getParsedSql</span><span class="o">(</span><span class="n">String</span> <span class="n">sql</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">parsedSqlCache</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">ParsedSql</span> <span class="n">parsedSql</span> <span class="o">=</span> <span class="o">(</span><span class="n">ParsedSql</span><span class="o">)</span> <span class="k">this</span><span class="o">.</span><span class="na">parsedSqlCache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">sql</span><span class="o">);</span>
</span><span class='line'>          <span class="k">if</span> <span class="o">(</span><span class="n">parsedSql</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>              <span class="n">parsedSql</span> <span class="o">=</span> <span class="n">NamedParameterUtils</span><span class="o">.</span><span class="na">parseSqlStatement</span><span class="o">(</span><span class="n">sql</span><span class="o">);</span>
</span><span class='line'>              <span class="k">this</span><span class="o">.</span><span class="na">parsedSqlCache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">sql</span><span class="o">,</span> <span class="n">parsedSql</span><span class="o">);</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>          <span class="k">return</span> <span class="n">parsedSql</span><span class="o">;</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>从上面的代码可以看到，NamedParameterJdbcTemplate不断的将解析过的SQL放入parsedSqlCache中，但并没有任何限制，而我们的service会根据不同的条件产生不同的SQL（条件参数比较多），同时这个SimpleJdbcTemplate也是share的，因此出现了out of memory的问题，当然，测试server的配置比较差也是其中一个原因。</p>

<p>这个问题可以参见<a href="https://jira.springsource.org/browse/SPR-7237">Spring Bug 7237</a>，该问题已在3.0.3中修复。</p>

<p>由于该阶段已不可能升级Spring的版本，潜在的风险太大，因此可自己实现一个NamedParameterJdbcTemplate，去override掉getParsedSql方法，可取消cache的作用，或参考Spring 3中的实现。</p>

<figure class='code'><figcaption><span>NamedParameterJdbcTemplate.java</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>   <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">DEFAULT_CACHE_LIMIT</span> <span class="o">=</span> <span class="mi">256</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>   <span class="kd">private</span> <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">cacheLimit</span> <span class="o">=</span> <span class="n">DEFAULT_CACHE_LIMIT</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>   <span class="kd">private</span> <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">ParsedSql</span><span class="o">&gt;</span> <span class="n">parsedSqlCache</span> <span class="o">=</span>
</span><span class='line'>          <span class="k">new</span> <span class="n">LinkedHashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">ParsedSql</span><span class="o">&gt;(</span><span class="n">DEFAULT_CACHE_LIMIT</span><span class="o">,</span> <span class="mf">0.75f</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">removeEldestEntry</span><span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">ParsedSql</span><span class="o">&gt;</span> <span class="n">eldest</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">return</span> <span class="nf">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">getCacheLimit</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="o">};</span>
</span><span class='line'>
</span><span class='line'>   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setCacheLimit</span><span class="o">(</span><span class="kt">int</span> <span class="n">cacheLimit</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">cacheLimit</span> <span class="o">=</span> <span class="n">cacheLimit</span><span class="o">;</span>
</span><span class='line'>   <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>   <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getCacheLimit</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">cacheLimit</span><span class="o">;</span>
</span><span class='line'>   <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>   <span class="kd">protected</span> <span class="n">ParsedSql</span> <span class="nf">getParsedSql</span><span class="o">(</span><span class="n">String</span> <span class="n">sql</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">getCacheLimit</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">return</span> <span class="n">NamedParameterUtils</span><span class="o">.</span><span class="na">parseSqlStatement</span><span class="o">(</span><span class="n">sql</span><span class="o">);</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">parsedSqlCache</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">ParsedSql</span> <span class="n">parsedSql</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">parsedSqlCache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">sql</span><span class="o">);</span>
</span><span class='line'>          <span class="k">if</span> <span class="o">(</span><span class="n">parsedSql</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>              <span class="n">parsedSql</span> <span class="o">=</span> <span class="n">NamedParameterUtils</span><span class="o">.</span><span class="na">parseSqlStatement</span><span class="o">(</span><span class="n">sql</span><span class="o">);</span>
</span><span class='line'>              <span class="k">this</span><span class="o">.</span><span class="na">parsedSqlCache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">sql</span><span class="o">,</span> <span class="n">parsedSql</span><span class="o">);</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>          <span class="k">return</span> <span class="n">parsedSql</span><span class="o">;</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>   <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后更改一下SimpleJdbcTemplate的实例化方式，先实例化一个改写过的NamedParameterJdbcTemplate，然后作为SimpleJdbcTemplate构造函数的参数来进行实例化。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[垃圾收集器及内存分配]]></title>
    <link href="http://askcuix.github.io/blog/2013/04/16/garbage-collection-and-memory-allocation/"/>
    <updated>2013-04-16T23:54:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2013/04/16/garbage-collection-and-memory-allocation</id>
    <content type="html"><![CDATA[<p>程序计数器、虚拟机栈和本地方法栈的内存分配大体在编译器就可以确定，并且这些区域和线程有着相同的生命周期，在方法或线程结束时，内存也就回收了。而Java堆和方法区的内存分配和回收都是动态的，只有在程序运行期间才知道会创建哪些对象，因此是垃圾收集器所关注的内存区域。</p>

<h2>对象标记算法</h2>

<p>Java堆中存放着所有对象实例，垃圾收集器在进行回收前，需要根据算法来确定哪些对象已不再被使用，可进行回收。</p>

<h3>引用计数算法</h3>

<p>该算法是给对象添加一个引用计数器，每当有引用它时，计数器就加1；当引用失效时，计数器就减1；当计数器为0时就不能被使用了。这种算法的判定效率很高，但是很难解决Java对象之间的循环引用问题，因此未被Java语言采用。</p>

<h3>根搜索算法</h3>

<p>通过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象当GC Roots没有任何引用链相连时，则此对象就不能被使用了。</p>

<p>可作为GC Roots的对象包括：
- 虚拟机栈中的局部变量表所引用的对象。 <br/>
- 方法区中的类静态属性引用的对象。  <br/>
- 方法区中的常量引用的对象。 <br/>
- 本地方法栈中JNI所引用的对象。</p>

<!-- more -->


<h2>Java引用</h2>

<p><strong>强引用</strong>：在代码中普遍存在的，比如“Object obj = new Object()”，只要强引用还存在，垃圾收集器则永远都不会回收引用的对象。</p>

<p><strong>软引用</strong>：一些还有用，但并非必须的对象。对于软引用关联的对象，在发生内存溢出之前，会将这些对象纳入回收范围并进行回收。</p>

<p><strong>弱引用</strong>：非必须对象，比软引用更弱一些，弱引用所关联的对象只能生存到下一次垃圾回收之前。当垃圾收集器工作时，无论当前内存是否够用，都会回收弱引用所关联的对象。</p>

<p><strong>虚引用</strong>：最弱的一种引用关系，一个对象是否被虚引用所关联，完全不会对其生存时间产生影响，也不能通过虚引用来取得对象实例，关联的唯一目的是在这个对象被垃圾回收器回收时收到一个系统通知。</p>

<h2>垃圾收集算法</h2>

<h3>标记-清除算法</h3>

<p>首先标记出所有需要回收的对象，之后统一回收所有被标记的对象。该算法效率较低，并会产生大量不连续的内存碎片。</p>

<h3>复制算法</h3>

<p>将新生代内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor，回收时将Eden和使用的Survivor中存活的对象一次性拷贝到另一块Survivor空间，然后清理Eden和之前使用的Survivor空间。</p>

<p>HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，因此新生代中可用内存为整个新生代容量的90%。当Survivor空间不够用时，将依赖老年代内存进行分配担保。</p>

<h3>标记-整理算法</h3>

<p>与标记-清除算法类似，但最后步骤不是直接对可回收对象进行清除，而是将所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>

<h3>分代收集算法</h3>

<p>将Java堆分为新生代和老年代，对每个年代采用合适的收集算法。</p>

<h2>垃圾收集器</h2>

<h3>Serial收集器</h3>

<p>单线程新生代收集器，在进行垃圾收集时，必须暂停所有的工作线程，导致停顿。与其它收集器的单线程相比简单高效，对于单CPU的环境没有线程交互的开销，收集效率较高。</p>

<h3>ParNew收集器</h3>

<p>新生代收集器，Serial收集器的多线程版本，是目前除Serial收集器外，唯一能够和CMS收集器配合工作的。默认开启的收集线程数与CPU的数量相同，可通过-XX:ParallelGCThreads来限制线程数。</p>

<p>ParNew收集器是使用-XX:+UseConcMarkSweepGC后的默认新生代收集器，也可以使用-XX:+UseParNewGC来强制指定。</p>

<h3>Parallel Scavenge收集器</h3>

<p>新生代收集器，以达到可控制的吞吐量为目标。可通过-XX:MaxGCPauseMillis来控制最大垃圾收集停顿时间，-XX:GCTimeRatio来控制吞吐量大小，-XX:+UseAdaptiveSizePolicy来实现自适应调节策略。</p>

<h3>Serial Old收集器</h3>

<p>Serial收集器的老年代版本。可在JDK1.5及之前版本中配合Parallel Scavenge收集器使用，也可在CMS收集器发生Concurrent Mode Failure时使用。</p>

<h3>Parallel Old收集器</h3>

<p>Parallel Scavenge收集器的老年代版本。使用多线程和“标记-整理”算法，在JDK1.6中开始提供。和Parallel Scavenge收集器配合使用非常适合注重吞吐量和CPU资源有限的场景。</p>

<h3>CMS（Concurrent Mark Sweep）收集器</h3>

<p>老年代收集器，以获取最短回收停顿时间为目标。默认启动的收集线程数是 (CPU数量+3) / 4。在并发阶段因占用一部分线程而导致应用程序变慢，总吞吐量下降。CMS收集器默认在老年代使用68%的空间后被激活，可通过调高-XX:CMSInitiatingOccupancyFraction来提高触发百分比，以降低内存回收次数。</p>

<p>若CMS运行期间预留的内存无法满足程序需要，就会出现“Concurrent Mode Failure”失败，虚拟机会临时启用Serial Old收集器来重新进行老年代的垃圾收集。</p>

<p>由于使用“标记-清除”算法会产生大量空间碎片，从而导致Full GC，可通过-XX:+UseCMSCompactAtFullCollection在Full GC后进行碎片整理。</p>

<h3>G1收集器</h3>

<p>使用“标记-整理”算法避免产生空间碎片，可以精确控制垃圾收集的时间。通过将整个Java堆划分为多个大小固定的独立区域，每次根据允许的收集时间，优先回收垃圾最多的区域，以此来保证在有限的时间内获取最高的收集效率。</p>

<h2>内存分配</h2>

<p>对象通常在新生代Eden区中分配，当Eden区没有足够空间时，将触发一次Minor GC。</p>

<p>需要大量连续内存的大对象将直接在老年代中分配，以避免新生代中发生大量的内存拷贝，可通过-XX:PretenureSizeThreshold来设置。</p>

<p>虚拟机为每个对象定义了年龄计数器，并通过Minor GC的次数来增加年龄，当达到-XX:MaxTenuringThreshold设置的阀值时，会将对象移入老年代。</p>

<p>若新生代中Survivor空间中相同年龄的对象大小总和大于Survivor空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代。</p>

<p><strong>新生代GC（Minor GC）</strong>：新生代的垃圾回收操作，Java对象的生命周期通常较短，因此Minor GC非常频繁。 <br/>
<strong>老年代GC（Major GC / Full GC）</strong>：老年代的垃圾回收操作，发生Full GC通常也会发生至少一次的Minor GC，GC的速度很慢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Korn Shell Script]]></title>
    <link href="http://askcuix.github.io/blog/2013/04/14/korn-shell-script/"/>
    <updated>2013-04-14T23:45:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2013/04/14/korn-shell-script</id>
    <content type="html"><![CDATA[<h2>基本语法</h2>

<p>&#8221;;&#8221;作为语句的结束，因此可以将多个command写在一行。</p>

<pre><code> print -n "Name: "; read name; print ""
</code></pre>

<p>&#8220;&#92;&#8221; 可将第二行command与第一行连接起来，若command太长，可通过这种方式写在多行上。</p>

<pre><code> grep filename | sort -u | awk '{print $4}' | \
 uniq -c &gt;&gt; /longpath/file
</code></pre>

<h2>Variables</h2>

<p><strong>Arrays</strong></p>

<p><strong>arrname[1]=4</strong>  To fill in <br/>
<strong>print ${arraname[1]}</strong>  To print out <br/>
<strong>${arrname[*]}</strong>  Get all elements <br/>
<strong>${#arrname[*]}</strong>  Get the number of elements</p>

<!-- more -->


<h2>Branching</h2>

<p><strong>if</strong></p>

<pre><code> if [[ $value -eq 7 ]]   

 then   
    print "$value is 7"   
 fi
</code></pre>

<p><strong>if … else</strong></p>

<pre><code> if [[ $name = "John" ]]
 then
    print "Your welcome, ${name}."
 else
    print "Good bye, ${name}!"
 fi
</code></pre>

<p><strong>if &#8230; elif &#8230; else</strong></p>

<pre><code> if [[ $name = "John" ]]
 then
    print "Your welcome, ${name}."
 elif [[ $name = "Hanna" ]]
 then
    print "Hello, ${name}, who are you?"
 else
    print "Good bye, ${name}!"
 fi
</code></pre>

<p><strong>case</strong></p>

<pre><code> case $var in
   john|fred)  print $invitation;;
   martin)  print $declination;;
   *)  print "Wrong name…";;
 esac
</code></pre>

<h2>Looping</h2>

<p><strong>while</strong></p>

<pre><code> while [[ $count -gt 0 ]];do
    print "\$count is $count"
    (( count -= 1 ))
 done
</code></pre>

<p><strong>until</strong></p>

<pre><code> until [[ $answer = "yes" ]];do
    print -n "Please enter \"yes\": "
    read answer
    print ""
 done
</code></pre>

<p><strong>for</strong></p>

<pre><code> for foo in $(ls);do
    if [[ -d $foo ]];then
       print "$foo is a directory"
    else
       print "$foo is not a directory"
    fi
 done
</code></pre>

<p><strong>continue</strong></p>

<pre><code> while read line
 do
   if [[ $line = *.gz ]];then
      continue
   else
      print $line
   fi
 done
</code></pre>

<p><strong>break</strong></p>

<pre><code> while read line;do
     if [[ $line = *!(.c) ]];then
        break
     else
        print $line
     fi
 done
</code></pre>

<h2>Comparisons</h2>

<p><strong>字符比较</strong>：&#8221;=&#8221;用于相等，&#8221;!=&#8221;用于不等。 <br/>
<strong>数字比较</strong>：&#8221;-eq&#8221;用于相等，&#8221;-ne&#8221;用于不等，&#8221;-gt&#8221;用于大于，&#8221;-lt&#8221;用于小于。 <br/>
<strong>与或比较</strong>：&#8221;&amp;&amp;&#8221;表示与，&#8221;||&#8221;表示或。</p>

<h2>变量操作</h2>

<p><strong>${name##*/}</strong>：用于从包含路径的变量中取出文件名。  <br/>
<strong>${name%/*}</strong>：用于从包含路径的变量中取出路径。  <br/>
<strong>dirname</strong>：用于获取文件的路径，不包含文件名。如：dirname $0 <br/>
<strong>${foo:-4}</strong>：如果foo不存在，则返回4，但foo仍然没有值。  <br/>
<strong>${foo:=4}</strong>：如果foo不存在，则附值4给foo。  <br/>
<strong>${foo:+1}</strong>：如果foo有值，则返回1，但foo的值不改变。  <br/>
<strong>${foo:?&#8221;foo not set!&#8221;}</strong>：如果foo不存在，则退出程序并显示&#8221;foo not set!&#8221;。 <br/>
<strong>${foo:startOffset}</strong>：从startOffset处开始截取字符串foo到末尾。 <br/>
<strong>${foo:startOffset:endOffset}</strong>：截取字符串foo从startOffset到endOffset。</p>

<h2>特殊变量</h2>

<p><strong>$#</strong>：命令行参数的个数。 <br/>
<strong>$1, &#8230;.$n</strong>：单个命令行参数。 <br/>
<strong>$*</strong>：所有的命令行参数。  <br/>
<strong>$0</strong>：当前script的名字，如果是从另外一个目录执行的，还将包含路径信息。  <br/>
<strong>$?</strong>：上个command执行结果的状态。 <br/>
<strong>$$</strong>：当前script的pid。  <br/>
<strong>$!</strong>：最后一个后台执行的程序的pid。 <br/>
<strong>shift</strong>：删除第一个命令行参数。</p>

<h2>数据重定向</h2>

<p><strong>command > file</strong>：将输出写到新文件或覆盖已存在的文件。 <br/>
<strong>command >> file</strong>：将输出添加在已存在文件中。 <br/>
<strong>command 2> file</strong>：将错误输出重定向到文件。 <br/>
<strong>command 2>/dev/null</strong>：丢弃错误信息。  <br/>
<strong>command 2>&amp;1</strong>：将错误输出重定向到正常输出。  <br/>
<strong>command &lt; file</strong>：从标准输入读取文件。  <br/>
<strong>command &lt; infile > outfile</strong>：组合输入和输出重定向。</p>

<h2>Read Input from User and from Files</h2>

<p><strong>read var</strong>：读取用户输入的变量。如：</p>

<pre><code> print -n "Enter your favorite haircolor: ";read var; print ""。
</code></pre>

<p><strong>按行读取文件的内容到变量</strong>：</p>

<pre><code> { while read myeline;do
      # process $myline
 done } &lt; filename
</code></pre>

<h2>Calculation</h2>

<p>简单的计算可通过 &#8220;let&#8221; 或  (( … ))。如：(( a+=1 )) 或 let a+=1。</p>

<h2>typeset用法</h2>

<p>typeset用于设置变量属性，如大小写、宽度、左右对齐等都可以用typeset来控制, 当用typeset改变一个变量的属性时,这种改变是永久的。</p>

<p>选项：</p>

<p><strong>-u</strong>：将一个变量的字符变成大写。  <br/>
<strong>-l</strong>：将一个变量的字符变成小写。  <br/>
<strong>-L<num></strong>：将变量变成一个左对齐的num长度的字符串，有些像字符串截取。 <br/>
<strong>-R<num></strong>：将变量变成一个右对齐的num长度的字符串。 <br/>
<strong>-Z<num></strong>：将变量变成一个空格填充，占num个字符位的字符串。 <br/>
<strong>-i</strong>：强制变量为一个整数。 <br/>
<strong>-r</strong>：设置一个只读变量。</p>

<p>文件状态测试</p>

<p><strong>-b filename</strong>：当filename 存在并且是块文件时返回真。 <br/>
<strong>-c filename</strong>：当filename 存在并且是字符文件时返回真。 <br/>
<strong>-d pathname</strong>：当pathname 存在并且是一个目录时返回真。 <br/>
<strong>-e pathname</strong>：当由pathname 指定的文件或目录存在时返回真。 <br/>
<strong>-f filename</strong>：当filename 存在并且是正规文件时返回真。 <br/>
<strong>-h filename</strong>：当filename 存在并且是符号链接文件时返回真。 <br/>
<strong>-r pathname</strong>：当由pathname 指定的文件或目录存在并且可读时返回真。 <br/>
<strong>-s filename</strong>：当filename 存在并且文件大小大于0 时返回真。 <br/>
<strong>-w pathname</strong>：当由pathname 指定的文件或目录存在并且可写时返回真。 <br/>
<strong>-x pathname</strong>：当由pathname 指定的文件或目录存在并且可执行时返回真。 <br/>
<strong>-O pathname</strong>：当由pathname 存在并且被当前进程的有效用户id 的用户拥有时返回真。 <br/>
<strong>-G pathname</strong>：当由pathname 存在并且属于当前进程的有效用户id 的用户的用户组时返回真。 <br/>
<strong>file1 -nt file2</strong>：file1 比file2 新时返回真。 <br/>
<strong>file1 -ot file2</strong>：file1 比file2 旧时返回真。</p>

<h2>字符串测试</h2>

<p><strong>-z string</strong>：字符串string 为空串(长度为0)时返回真。 <br/>
<strong>-n string</strong>：字符串string 为非空串时返回真。</p>

<h2>Resources</h2>

<p>Korn Shell Programming：<a href="http://www.bo.infn.it/alice/alice-doc/mll-doc/impgde/node15.html">http://www.bo.infn.it/alice/alice-doc/mll-doc/impgde/node15.html</a> <br/>
Learning the Korn Shell: <a href="http://docstore.mik.ua/orelly/unix/ksh/">http://docstore.mik.ua/orelly/unix/ksh/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The foundation of spring batch]]></title>
    <link href="http://askcuix.github.io/blog/2013/04/01/the-foundation-of-spring-batch/"/>
    <updated>2013-04-01T22:46:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2013/04/01/the-foundation-of-spring-batch</id>
    <content type="html"><![CDATA[<p>Spring Batch是埃森哲贡献给Spring的一个开源项目，现在由双方共同维护。通过Spring Batch可以构建出轻量级的大数据量并⾏处理应⽤,⽀持事务、并发、流程、监控、纵向和横向扩展,提供统一的接口管理。Spring Batch并不包含scheduler，它只是一个通用的batch处理框架，你可以通过QuartZ，Control-M等scheduler去调用。</p>

<p>Spring Batch能够处理大批量数据的导入、导出和业务逻辑计算，执行过程无需人工干预。我们的系统是一个金融产品信息的数据中心，需要从不同的系统读取产品信息，也需要将这些信息提供给其它的系统，这种data loading就是Spring Batch的一种应用场景。</p>

<!-- more -->


<p><img src="http://askcuix.github.io/images/blog/spring_batch_common_process.png" alt="Spring Batch Common Process" /></p>

<p>上图就是Spring Batch的常用方式，从DB或是不同类型的文件中读取数据，经过转换后再写入DB或者文件。</p>

<p><img src="http://askcuix.github.io/images/blog/spring_batch_domain.png" alt="Spring Batch Domain" /></p>

<p>上图是一个Job执行的结构图，下面是对这些domain对象的简单描述，只是学习时随笔记下来的，不够详细，可以查看Spring Batch文档中的描述。</p>

<h2>Job</h2>

<p>Job是对一个batch处理流程的定义，可以简单理解为Spring中的一个Job配置，一般都包括reader和writer。</p>

<h2>JobInstance</h2>

<p>JobInstance是Job运行时产生的实例，如果这个Job是按天执行的，则每天都会创建一个JobInstance；当Job执行失败时，restart这个Job将会重用JobInstance，以便于从执行失败的地方开始重新执行。</p>

<h2>JobParameter</h2>

<p>JobParameter用于标识一个JobInstance，可以将它理解为JobInstance的ID。</p>

<h2>JobListener</h2>

<p>JobListener可以监听JobInstance生命周期中的两个事件：</p>

<p><strong>beforeJob</strong> - 在Job执行前被调用。</p>

<p><strong>afterJob</strong> - 不论Job执行成功或失败都会被调用，Job的status可以从JobExecution中获取。</p>

<h2>Parent Job</h2>

<p>对于相似的Job，可以取出相同的部分定义成一个parent Job，只需要在Job定义时添加<em>abstract=&#8221;true&#8221;</em>，然后在sub Job中通过<em>parent</em>属性来指定parent Job。</p>

<h2>JobRepository</h2>

<p>MapJobRepository通常用于测试环境或是standalone的batch。它不够稳定；不允许在不同JVM实例之间执行restart；也不能保证有相同JobParameter的两个JobInstance同时运行；它不适合在多线程Job或本地的partition step中使用。但是它仍然需要配置transaction manager，因为在Job的实现中会涉及到rollback的问题，所以可以用ResourcelessTransactionManager来代替。</p>

<h2>JobLauncher</h2>

<p>JobLauncher使用spring的taskExecutor来实现异步处理，只需要在配置中指定taskExecutor属性。如果batch是通过http request的方式触发的，那应当使用异步的方式来处理Job以避免长时间的占用链接。</p>

<h2>JobOperator</h2>

<p>JobOperator的stop()不会立刻停止一个Job，如果当前流程处理的控制权在framework，则会将StepExecution的status设置为STOPPED并保存，然后按正常的处理流程结束Job。</p>

<p>如果不希望一个restartable的Job在执行失败后restart，可以将status设置为ABORTED。</p>

<h2>JobParametersIncrementer</h2>

<p>JobParametersIncrementer可强制创建一个新的jobInstance，以避免在使用相同JobParameter时不可以再次执行Job。这只是个接口，需要自己去实现getNext()，然后在Job中定义incremented属性来引用它。</p>

<h2>Step</h2>

<p><strong>start-limit</strong>： 用于step的restart，用来控制一个start的次数。默认是Integer.MAX_VALUE。<br/>
<strong>allow-start-if-complete</strong>： 强制执行step，不管之前执行成功或失败。</p>

<h3>Skip</h3>

<p>通过指定exception来决定是否skip有问题的数据，可以结合include和exclude来定义exception列表。</p>

<p><strong>skip-limit</strong>：用来控制允许skip的数据的最大数量，在step execution中分别保存有针对read，process和write中skip的数量。</p>

<h3>Retry</h3>

<p>通过指定exception来指定是否允许重试当前有问题的错误数据，对于一些通过重试可以解决问题的数据是非常有用的，比如更新当前数据到DB时，该条数据被其它进程lock了，则在重试时可能就可以正常更新了。</p>

<p><strong>retry-limit</strong>：用来控制每个item允许重试的次数。</p>

<h3>Rollback</h3>

<p>通过指定exception来忽略rollback操作。对于Skip和Retry，如果Exception是由ItemWriter抛出的，则step中被当前transaction控制的数据会被rollback，因此要配合使用no-rollback-exception-classes来决定是否应该执行rollback。</p>

<p>Step通常会缓存Reader读入的数据，如果发生了rollback则不需要重新读入数据，但是对于一些基于transaction资源的Reader，比如从JMS queue中读取数据的Reader，JMS message也会执行rollback，则需要通过is-reader-transactional-queue来标识不需要缓存读入数据。</p>

<h2>ItemStream</h2>

<p>在Step执行失败需要restart时，可以通过ItemStream获取存储在execution之间状态信息。如果ItemReader，ItemProcessor或者ItemWriter实现了ItemStream接口，则会自动被注册在Spring Context中；否则需要单独注册streams。对于CompositeItemWriter，如果delegate的ItemWriter实现了ItemStream接口，也需要主动注册。</p>

<h2>StepListener</h2>

<p>和ItemStream一样，如果ItemReader，ItemProcessor或者ItemWriter实现了StepListener接口，则会被自动注册。</p>

<h3>StepExecutionListener</h3>

<p><strong>beforeStep</strong> - 在step执行之前调用。<br/>
<strong>afterStep</strong> - 在step结束时调用，不管执行成功或失败。可以在这里更改ExitStatus。</p>

<h3>ChunkListener</h3>

<p><strong>beforeChunk</strong> - 被调用在transaction开始后，但在ItemReader的read方法执行前。<br/>
<strong>afterChunk</strong> - chunk被commit/rollback后被调用。</p>

<p>ChunkListener也可被用在未使用chunk方式的step中，比如Tasklet， 会在tasklet执行前后被调用。</p>

<h3>ItemReadListener</h3>

<p><strong>beforeRead</strong> - 在read方法执行前被调用。<br/>
<strong>afterRead</strong> - 在read方法执行成功后被调用，并返回读到的item作为参数。<br/>
<strong>onReadError</strong> -  在read方法出现异常时被调用，并提供异常的类型作为参数。</p>

<h3>ItemProcessListener</h3>

<p><strong>beforeProcess</strong> - 在ItemProcessor的process方法执行前被调用。<br/>
<strong>afterProcess</strong> - 在process方法执行成功后被调用。<br/>
<strong>onProcessError</strong> - 在process方法出现异常时被调用，并提供item和异常作为参数。</p>

<h3>ItemWriteListener</h3>

<p><strong>beforeWrite</strong> - 在ItemWriter的write方法执行前被调用。<br/>
<strong>afterWrite</strong> - 在ItemWriter的write方法执行成功后被调用。<br/>
<strong>onWriteError</strong> - 在ItemWriter的write方法出现异常时被调用，并提供chunk data和异常作为参数。</p>

<h3>SkipListener</h3>

<p><strong>onSkipInRead</strong> - 当item在读取阶段skip时被调用。 <br/>
<strong>onSkipInProcess</strong> - 当item在process阶段skip时被调用。<br/>
<strong>onSkipInWrite</strong> -  当item在写入阶段skip时被调用，并且在transaction被commit之前。</p>

<h3>Batch Status vs. Exit Status</h3>

<p>Conditional Flow的配置中的on属性使用Exit Status，通常情况下Batch Status和Exit Status是一样的，但StepExecutionListener可以更改Exit Status。</p>

<h3>Step Scope</h3>

<p>使用Job和Step的属性延迟绑定特性时，必须将Bean的scope设置为step。使用该属性可以通过定义Spring Batch的namespace或者定义StepScope。</p>

<figure class='code'><figcaption><span>applicationContext.xml</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>   <span class="nt">&lt;bean</span> <span class="na">class=</span><span class="s">&quot;org.springframework.batch.core.scope.StepScope&quot;</span> <span class="nt">/&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h2>Resources</h2>

<p>Official site: <a href="http://www.springsource.org/spring-batch">http://www.springsource.org/spring-batch</a></p>

<p>IBM DeveloperWorks - 使用 Spring Batch 构建企业级批处理应用:<br/>
 - <a href="http://www.ibm.com/developerworks/cn/java/j-lo-springbatch1/">http://www.ibm.com/developerworks/cn/java/j-lo-springbatch1/</a><br/>
 - <a href="http://www.ibm.com/developerworks/cn/java/j-lo-springbatch2/">http://www.ibm.com/developerworks/cn/java/j-lo-springbatch2/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Common Format of CSV Files]]></title>
    <link href="http://askcuix.github.io/blog/2013/03/26/common-format-of-csv-files/"/>
    <updated>2013-03-26T23:43:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2013/03/26/common-format-of-csv-files</id>
    <content type="html"><![CDATA[<p>CSV是一种常见的文件格式，常用于不同系统之间的数据交换，对于该文件格式可以简单描述为：一组使用逗号“,”分隔字段，并以换行符作为一行数据结束的数据集合。该文件可以使用Microsoft Excel查看，但是中文字符会显示为乱码。</p>

<p>这个描述就真的只是简单描述，实际上CSV的格式处理没有这么简单。最近在和另外一个系统做集成，我们的系统会提供CSV数据文件给对方系统处理，由于我们系统中个别字段会包括换行符“CRLF”（这是遗留系统，就不用纠结为什么字段中会包含换行符了），也就是说一个字段可能会显示在几行上，但是这个字段是包含在双引号中的，结果对方系统就处理不了了。因为对方系统只是简单的按行处理数据，用逗号解析字段。</p>

<!-- more -->


<p>这种解析方式通常是没有问题，但是是不完整的。<a href="http://tools.ietf.org/html/rfc4180"><strong>RFC 4180</strong></a>是CSV格式的标准，这里提到并没有官方的规范去定义CSV的格式到底是怎样的，但是根据大多数的实现来看，应该有如下格式：</p>

<ul>
<li><p>每条数据用换行符（CRLF）分割。</p></li>
<li><p>最后一条数据可以不包含换行符。</p></li>
<li><p>可选的header行，如有的话，应该出现在第一行，并且与下面的数据有相同数量的字段。</p></li>
<li><p>在header和每条数据中，使用逗号“,”分隔字段，每一行都应该包含相同数量的字段，空白字符也可作为一个字段，一条数据的最后一个字段不应添加逗号分隔符。</p></li>
<li><p>每个字段可以包含在双引号中。</p></li>
<li><p>如果字段中包含换行符（CRLF），双引号和逗号，则必须将字段包含在双引号中。</p></li>
<li><p>如果字段中包含双引号，则除了需要将字段包含在双引号中，还要在字段中的双引号前再加一个双引号作为转义。</p></li>
</ul>


<p>由此可见，字段中是允许出现换行符的，只要该字段是包含在双引号中的。我也查阅了Spring Batch的CSV Reader的实现，也考虑到了该问题，在发现换行符的同时，也会检查当前字段是否已结束。</p>

<p>因此，我们在生成或解析CSV文件时，应该要考虑到以上特殊字符的处理，在apache的common-lang包中，也有专门针对CSV字符的转义方法，可参考<a href="http://commons.apache.org/proper/commons-lang/javadocs/api-release/org/apache/commons/lang3/StringEscapeUtils.html">StringEscapeUtils</a>，在最大程度上保证系统的robust。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM运行时内存区域]]></title>
    <link href="http://askcuix.github.io/blog/2013/03/26/the-runtime-memory-of-jvm/"/>
    <updated>2013-03-26T23:31:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2013/03/26/the-runtime-memory-of-jvm</id>
    <content type="html"><![CDATA[<p>Java虚拟机管理的运行时数据区域：</p>

<ul>
<li><p>程序计数器</p>

<p>是当前线程所执行的字节码的行号指示器。每条线程都有一个独立的程序计数器，各线程之间的计数器互不影响，该内存区域为线程私有，也不会出现OutOfMemoryError。</p></li>
<li><p>Java虚拟机栈</p>

<p>该区域也是线程私有，其生命周期与线程相同。虚拟机栈表述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>

<p><!-- more --></p>

<p>局部变量表存放了编译期可知的基本类型、对象引用（可能是一个指向对象起始地址的指针，也可能是指向一个对象的句柄，或者是与此对象相关的位置）和retuanAddress类型。64位长度的long和double类型占用2个局部变量空间，其余类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，方法运行期间不会改变。</p>

<p>在本区域中，若线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError；若动态扩展无法申请到足够的内存时抛出OutOfMemoryError。</p></li>
<li><p>本地方法栈</p>

<p>与虚拟机栈的作用相似，区别是虚拟机栈为虚拟机执行Java方法服务，本地方法栈为虚拟机使用到的Native方法服务。有的虚拟机实现会将虚拟机栈和本地方法栈合在一起。</p></li>
<li><p>Java堆</p>

<p>可被所有线程共享，在虚拟机启动时创建。此区域只用于存放对象实例，是垃圾收集器管理的主要区域。堆的扩展可通过-Xmx和-Xms控制。若堆中没有内存完成实例分配，也无法扩展时，将抛出OutOfMemoryError。</p></li>
<li><p>方法区</p>

<p>可被所有线程共享，用于存放已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虚拟机规范将方法区描述为堆的一个逻辑部分。该区域很少进行垃圾回收的操作。</p>

<p>若方法区无法满足内存分配需求时，将抛出OutOfMemoryError。</p></li>
</ul>


<h2>对象访问方式</h2>

<p>虚拟机规范中未定义对象访问的方式，在主要的虚拟机实现中包含如下两种方式：</p>

<ul>
<li><p>句柄访问</p>

<p>在Java堆中划分出一块内存作为句柄池，Java栈中对象引用存储的就是对象的句柄地址，句柄中包含了对象实例数据和类型数据的地址信息。</p>

<p>这种方式在对象引用中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，对象引用本身不需要被修改。</p></li>
<li><p>指针访问</p>

<p>Java栈中对象引用存储的就是对象的地址。这种方法的访问速度更快，节省了一次指针定位的开销。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Supplementary Characters in Java]]></title>
    <link href="http://askcuix.github.io/blog/2013/03/15/supplementary-characters-in-java/"/>
    <updated>2013-03-15T23:37:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2013/03/15/supplementary-characters-in-java</id>
    <content type="html"><![CDATA[<p>工作中经常会涉及到文件处理，而fixlength类型的文件又是一种很常见的格式。众所周知，fixlength类型的数据就是每个字段对应一行数据中固定长度的字符，每个字段都有对应的start offset和end offset，用实现来表示就是String.substring(start, end)，所以start和end的位置是至关重要的，一个字段对应错了，后面的字段就全错了。</p>

<p>在Java中使用UTF-16来表示unicode字符，一个字符就是16 bit，像String.length()就是返回有多少个16 bit。unicode支持的字符的code point范围是U+0000到U+10FFFF，这其中包括基本字符（BMP）和补充字符（supplementary character），基本字符时从U+0000到U+FFFF，补充字符从U+10000到U+10FFFF。<!-- more -->在UTF-16编码中，基本字符占用一个16 bit，而补充字符占用两个16 bit。这样Java String的很多方法就会出现问题了，当然也包括上面提到的substring和length。那么如果fixlength文件中含有补充字符，则会导致字段map错误。</p>

<p>那现在来看如何解决这个问题，一个解决办法是对字符串做Base64编码，编码之后的字符都是单个16 bit了。但是这有两个弊端，一是Base64之后会使数据变大，有时我们会将这些fixlength的数据作为JMS Message，对于这种情况，数据变大是不建议的；另一个问题是Base64操作的CPU消耗会比较大，会影响到performance。因此虽然这种方法可以解决问题，但是不推荐。</p>

<p>另一个解决办法是使用IBM的ICU4J，这个API提供了很多国际化相关的工具类，使用它来重新实现我们用到的String方法，这里可以参考我写的一个工具类<a href="https://github.com/askcuix/easeframe/blob/master/modules/core/src/main/java/com/easeframe/core/lang/Unicode.java">Unicode</a>。</p>

<p>因为我们一直用Spring Batch来处理文件，便查阅了一下源码看有没有考虑到supplementary character的问题，结果这个问题也被忽视了，看来supplementary character的使用还是比较少，但如果系统需要支持多语言的环境，还是自己处理一下比较好，之后我会重写一个Spring Batch的FixLengthItemWriter，增加对supplementary character的支持。</p>

<p>这里有一些资源可供参考：</p>

<ul>
<li><a href="http://www.unicode.org">unicode.org</a></li>
<li><a href="http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html">Supplementary Characters in the Java Platform</a></li>
<li><a href="http://docs.oracle.com/javase/tutorial/i18n/text/index.html">Working with Text</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The syntax of markdown]]></title>
    <link href="http://askcuix.github.io/blog/2013/03/10/the-syntax-of-markdown/"/>
    <updated>2013-03-10T17:36:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2013/03/10/the-syntax-of-markdown</id>
    <content type="html"><![CDATA[<p>Octopress使用的是markdown语法，和wiki的语法有点相似，但又不完全相同，这里将常用的语法记录下来便于查阅。</p>

<h2>标题</h2>

<p>标题用#开头，一个#是一级标题，两个#是二级标题，#越多字体越小。</p>

<!-- more -->


<h2>换行</h2>

<p>在每一行的末尾以两个或更多个空格符号结束，然后再打回车键，即可实现 <code>&lt;br /&gt;</code>的效果。</p>

<h2>链接</h2>

<p><code>[text](link)</code>
创建文本链接。</p>

<h2>图片</h2>

<p>与链接类似，区别是前面增加叹号!：</p>

<p><code>![text](link)</code></p>

<h2>引用</h2>

<p>用<code>&gt;</code>开头的一个段落。</p>

<p>用四个空格缩进的段落，会按原始格式显示。也可以通过在引用段落的前后各加一行波浪号~~~~~~来实现。</p>

<h2>显示效果</h2>

<p>用<code>*</code>或<code>_</code>包围的文字会用斜体显示。</p>

<p>双重符号<code>**</code>或<code>__</code>则会用粗体显示。</p>

<p>用`包围的文字按代码格式显示。</p>

<h2>列表</h2>

<p>无序列表用*, +, -开头。子项缩进两个空格。</p>

<p>有序列表用数字加英文句点。</p>

<h2>水平线</h2>

<p>在一行里只放三个或更多个<code>\</code>，或<code>*</code>或<code>_</code>，就可以实现水平线标记<code>&lt;hr /&gt;</code></p>

<h2>脚注</h2>

<p>以<code>[^1]:</code> 开头，后面跟着定义。</p>

<h2>嵌入代码</h2>

<pre><code> ``` [language] [title] [url] [link text]
   code snippet
 ```
</code></pre>

<h2>转义</h2>

<p>用<code>\</code>可转义Markdown元字符。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress常用命令]]></title>
    <link href="http://askcuix.github.io/blog/2013/03/10/the-common-commands-of-octopress/"/>
    <updated>2013-03-10T17:34:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2013/03/10/the-common-commands-of-octopress</id>
    <content type="html"><![CDATA[<p>Octopress经常使用到的命令，在这里做个总结，方面查阅。</p>

<pre><code>rake new_post["title"]
</code></pre>

<p>创建一个post。</p>

<pre><code>rake new_page[super-awesome/page.html]
</code></pre>

<p>创建一个page。</p>

<!-- more -->


<pre><code>&lt;!-- more --&gt;
</code></pre>

<p>插入到文章当中，用来实现摘要模式。</p>

<pre><code>keywords: 
description: 
</code></pre>

<p>在post和page开头添加以上两项属性，可更改Octopress默认的keywords和description，以提高SEO。</p>

<pre><code>rake generate
</code></pre>

<p>生成post/page。</p>

<pre><code>rake preview
</code></pre>

<p>预览效果：http://localhost:4000</p>

<pre><code>rake deploy
</code></pre>

<p>deploy到github。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[New Blog Opening]]></title>
    <link href="http://askcuix.github.io/blog/2013/03/06/new-blog-opening/"/>
    <updated>2013-03-06T23:42:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2013/03/06/new-blog-opening</id>
    <content type="html"><![CDATA[<p>新blog开张啦，以此博文作为纪念。</p>

<p>这些年折腾了好几个博客了，但加起来的文字总共也没有多少，我的热乎劲也就在搭建那一刹那，特别是像在GAE上要自己去折腾整个过程。所以说，我并不热衷于写博客，而是中意于搭建这样一个小站的过程。说到原因呢，可能是因为哥曾经也是个web developer，但最近几年一直在做backend，把以前的frontend功底也丢的差不多了，所以每次遇到这样的机会，总是会让我心潮澎湃。</p>

<!-- more -->


<p>Github是developer的聚集地，尤其是开源爱好者们，搭建这个blog也是为了更亲近这个社区，octopress被很多developer用来在Github上搭建blog，也想了解下，顺便沾染点geeker的感觉。</p>

<p>以前从没接触过ruby，也不知什么原因，就是对它没兴趣，我更愿意去用python，结果这次的搭建过程真叫折腾。从在Mac上安装ruby，到彻底安装上octopress，不断的遇到gcc，make，openssl等问题，不知道重试了多少遍，最后还是按照ruby China上的wiki，用了淘宝的mirror才安装成功。Linux功底不行啊，对这些问题完全束手无策。</p>

<p>不知道会在这个blog上写多少东西，准备在这里纪录一些学习笔记，平时很多东西都记录在Evernote上了，今后可以选择性的放一些在这里。前面也说过了，我并不擅长于写博客，因为我的文笔实在不咋地，写一篇拿出来见人的东西要花费很长时间，慢慢地也就没了兴趣，另一方面，自己也确实缺乏毅力，总是没能坚持写下去。我希望自己对待这个blog能有点毅力，既是对自己学习过程的监督，也是对写作能力的培养。</p>

<p><strong><em>Keep Walking……</em></strong></p>
]]></content>
  </entry>
  
</feed>

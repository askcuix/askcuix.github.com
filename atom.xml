<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Chris's Blog]]></title>
  <link href="http://askcuix.github.io/atom.xml" rel="self"/>
  <link href="http://askcuix.github.io/"/>
  <updated>2014-01-24T12:09:58+08:00</updated>
  <id>http://askcuix.github.io/</id>
  <author>
    <name><![CDATA[Chris]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Postgresql常用命令]]></title>
    <link href="http://askcuix.github.io/blog/2014/01/24/the-command-of-postgresql/"/>
    <updated>2014-01-24T10:37:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2014/01/24/the-command-of-postgresql</id>
    <content type="html"><![CDATA[<p>Postgresql提供了很多快捷的命令，可以很方便的在命令行中使用。以<strong>\</strong>开头的命令需要进入psql执行。</p>

<h2>数据库管理</h2>

<p><strong>创建用户</strong></p>

<pre><code>CREATE USER chris WITH CREATEDB ENCRYPTED PASSWORD '123456';
</code></pre>

<p><strong>更改用户</strong></p>

<pre><code>ALTER USER chris WITH ENCRYPTED PASSWORD 'chris123';
</code></pre>

<p><strong>列出所有的Roles</strong></p>

<pre><code>SELECT rolname FROM pg_roles;

or

\du 
</code></pre>

<p><strong>创建Database</strong></p>

<pre><code>CREATE DATABASE dbname;

or

createdb dbname
</code></pre>

<p><strong>Grant Right</strong></p>

<pre><code>GRANT ALL PRIVILEGES ON DATABASE mydb to chris;
</code></pre>

<p><strong>创建Database并指定Role</strong></p>

<pre><code>CREATE DATABASE dbname OWNER rolename;

or

createdb -O rolename dbname
</code></pre>

<p><strong>删除Database</strong></p>

<pre><code>DROP DATABASE name;

or

dropdb dbname
</code></pre>

<p><strong>列出所有的Databases</strong></p>

<pre><code>SELECT datname FROM pg_database;

or

\l
</code></pre>

<p><strong>切换Database</strong></p>

<pre><code>\c dbname
</code></pre>

<p><strong>列出所有的Tablespaces</strong></p>

<pre><code>SELECT spcname FROM pg_tablespace;

or

\db
</code></pre>

<p><strong>列出当前Database的所有Tables</strong></p>

<pre><code>\dt
</code></pre>

<p><strong>查看Table</strong></p>

<pre><code>\d tablename
</code></pre>

<p><strong>列出当前Database的所有Functions</strong></p>

<pre><code>\df
</code></pre>

<!-- more -->


<h2>系统管理</h2>

<p>以下Postgresql相关的路径信息以Ubuntu为例。</p>

<h3>启动/停止服务</h3>

<p>启动Postgresql服务：</p>

<pre><code>sudo /etc/init.d/postgresql start
</code></pre>

<p>停止Postgresql服务：</p>

<pre><code>sudo /etc/init.d/postgresql stop
</code></pre>

<p>重启Postgresql服务：</p>

<pre><code>sudo /etc/init.d/postgresql reload
</code></pre>

<h3>检查Postgresql进程</h3>

<pre><code>ps auxww | grep ^postgres
</code></pre>

<h3>Database Log</h3>

<pre><code>/var/log/postgresql  
</code></pre>

<h3>查看系统参数</h3>

<pre><code>show &lt;parm_name&gt;
</code></pre>

<h3>查看连接数</h3>

<pre><code>select count(1) from pg_stat_activity; 
</code></pre>

<h3>数据库备份</h3>

<pre><code>pg_dump -h host -p port -U user dbname &gt; outfile
</code></pre>

<h3>数据库恢复</h3>

<pre><code>psql -h host -p port dbname &lt; infile
</code></pre>

<h3>开启远程访问</h3>

<p>在postgresql.conf中更改listen_addresses：</p>

<pre><code>sudo vi /etc/postgresql/9.1/main/postgresql.conf       

listen_addresses="*"
</code></pre>

<p>在pg_hba.conf中添加host：</p>

<pre><code>sudo vi /etc/postgresql/9.1/main/pg_hba.conf

host  all  all 0.0.0.0/0  md5
</code></pre>

<h3>调整Database的最大连接数</h3>

<p>Postgresql的最大连接数默认是100，如果我们同时有很多程序一起连接，有时是不够用的，可以postgresql.conf中的参数来调大连接数。</p>

<pre><code>sudo vi /etc/postgresql/9.1/main/postgresql.conf
</code></pre>

<p>更改以下两个参数的值：</p>

<pre><code>shared_buffers: 25% - 50% of the system RAM
max_connections: max_connections * work_mem &lt; RAM
</code></pre>

<p>更改之后需要重启Postgresql，如果遇到SHMMAX not enough的错误，则需要更改SHMMAX的大小。</p>

<pre><code>sudo vi /etc/sysctl.d/30-postgresql-shm.conf
</code></pre>

<p>更改kernel.shmmax的值，值的大小可以参考之前错误中的提示。</p>

<p>更改完之后需要reload configure:</p>

<pre><code>sudo service procps start
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting start with GoLang]]></title>
    <link href="http://askcuix.github.io/blog/2014/01/23/getting-start-with-go-lang/"/>
    <updated>2014-01-23T17:50:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2014/01/23/getting-start-with-go-lang</id>
    <content type="html"><![CDATA[<p>Go语言以简单、并行、高效等优点已推出了好几年，但真正影响到很多人去关注的，应该是在最近一年，Go被成功运用到云计算等领域，也出现了越来越多的拥护者。最近因为工作的需要，也开始关注一些并行计算方面的东西，并行作为Go的一大卖点，自然要去了解一下。</p>

<p>我在Mac下先用HomeBrew安装了Go，不过发现安装出来的包不够全，没有godoc，其它还少了什么东西就没去仔细看了，然后还是从官方下载tar包来用。</p>

<p>安装完之后，除了将bin目录加入到path中，还有设置更重要的一个环境变量GOPATH。完成之后就可以开始体验Go了。</p>

<h2>GOPATH</h2>

<p>GOPATH为工作目录，也就是我们写Go程序的workspace。</p>

<p>按照约定，通常有以下三个子目录：</p>

<p><strong>src</strong>：存放源代码（比如：.go等）<br/>
<strong>pkg</strong>：编译后生成的文件（比如：.a）<br/>
<strong>bin</strong>：编译后生成的可执行文件（为了方便，可以把此目录加入到 $PATH 变量中）</p>

<!-- more -->


<h2>Go常用命令</h2>

<h3>go build</h3>

<p>用于编译源文件。在包的编译过程中，若有必要，会同时编译与之相关联的包。</p>

<p>该命令会忽略目录下以“_”或“.”开头的go文件。</p>

<h3>go clean</h3>

<p>用于移除当前源码包里面编译生成的文件。这些文件包括：</p>

<p><strong>_obj/</strong>：旧的object目录，由Makefiles遗留<br/>
<strong>_test/</strong>：旧的test目录，由Makefiles遗留<br/>
<strong>_testmain.go</strong>：旧的gotest文件，由Makefiles遗留<br/>
<strong>test.out</strong>：旧的test记录，由Makefiles遗留<br/>
<strong>build.out</strong>：旧的test记录，由Makefiles遗留<br/>
<strong>*.[568ao]</strong>：object文件，由Makefiles遗留</p>

<p><strong>DIR(.exe)</strong>：由go build产生<br/>
<strong>DIR.test(.exe)</strong>：由go test -c产生<br/>
<strong>MAINFILE(.exe)</strong>：由go build MAINFILE.go产生</p>

<h3>go fmt</h3>

<p>用于格式化源代码文件。</p>

<h3>go get</h3>

<p>用于获取远程代码包，目前支持的有BitBucket、GitHub、Google Code和Launchpad。</p>

<p>这个命令在内部实际上分成了两步操作：第一步是下载源码包，第二步是执行go install。</p>

<h3>go install</h3>

<p>这个命令在内部实际上分成了两步操作：第一步是生成结果文件(可执行文件或者.a包)，第二步会把编译好的结果移到 <em>$GOPATH/pkg</em> 或者 <em>$GOPATH/bin</em>。</p>

<h3>go test</h3>

<p>这个命令会自动读取源码目录下面名为<strong>*_test.go</strong>的文件，生成并运行测试用的可执行文件。</p>

<h3>godoc</h3>

<p>查看API文档。</p>

<p>在命令行执行 <code>godoc -http=:&lt;port&gt;</code>，比如 <em>godoc -http=:8080</em>。然后在浏览器中打开127.0.0.1:8080，你将会看到一个golang.org的本地版本，通过它可以查询pkg文档等其它内容。如果你设置了GOPATH，在pkg分类下，不但会列出标准包的文档，还会列出你本地GOPATH中所有项目的相关文档。</p>

<h3>go fix</h3>

<p>用来修复以前老版本的代码到新版本，例如go1之前老版本的代码转化到go1。</p>

<h3>go version</h3>

<p>查看go当前的版本。</p>

<h3>go env</h3>

<p>查看当前go的环境变量。</p>

<h3>go list</h3>

<p>列出当前全部安装的package。</p>

<h3>go run</h3>

<p>编译并运行Go程序。</p>

<p>准备好了开发环境，熟悉了以上常用的命令，就可以开始Go程序的旅程了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PostgreSQL installation on MAC]]></title>
    <link href="http://askcuix.github.io/blog/2013/08/12/postgresql-installation-on-mac/"/>
    <updated>2013-08-12T19:55:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2013/08/12/postgresql-installation-on-mac</id>
    <content type="html"><![CDATA[<ol>
<li><p><strong>Use MacPorts install PostgreSQL server</strong></p>

<pre><code> sudo port install postgresql93-server
</code></pre></li>
<li><p><strong>Create Database Instance</strong></p>

<pre><code> sudo mkdir -p /opt/local/var/db/postgresql93/defaultdb  
 sudo chown postgres:postgres /opt/local/var/db/postgresql93/defaultdb  
 sudo su postgres -c '/opt/local/lib/postgresql93/bin/initdb -D /opt/local/var/db/postgresql93/defaultdb'  
 sudo mkdir -p /opt/local/var/log/postgresql  
 sudo chown postgres:postgres /opt/local/var/log/postgresql  
</code></pre></li>
<li><p><strong>Start Database Server</strong></p>

<pre><code> sudo su postgres -c '/opt/local/lib/postgresql93/bin/postgres -D /opt/local/var/db/postgresql93/defaultdb'  
</code></pre>

<p>or</p>

<pre><code> sudo su postgres -c '/opt/local/lib/postgresql93/bin/pg_ctl -D /opt/local/var/db/postgresql93/defaultdb -l /opt/local/var/log/postgresql/postgres.log start'
</code></pre></li>
<li><p><strong>Set PATH environment variable</strong></p>

<pre><code> export PATH=/opt/local/lib/postgresql93/bin:$PATH
</code></pre>

<p> Make sure you set the PostgreSQL path before /usr/bin to ensure that you are using the latest versions and not the default Apple provided, otherwise will encounter error when execute operation.</p></li>
<li><p><strong>Create User</strong></p>

<pre><code> createuser --superuser Chris -U postgres
</code></pre></li>
<li><p><strong>Create Database</strong></p>

<pre><code> createdb mydb
</code></pre>

<p>If below error encountered, that caused by you use old version PostgreSQL which provide by Apple, change PATH environment variable to solve.</p>

<pre><code>  createdb: could not connect to database postgres: could not connect to server: No such file or directory   
     Is the server running locally and accepting
     connections on Unix domain socket "/var/pgsql_socket/.s.PGSQL.5432"?
</code></pre></li>
<li><p><strong>Accessing Database</strong></p>

<pre><code> psql mydb
</code></pre>

<p><strong>mydb=#</strong> means you are a database superuser, otherwise display <strong>mydb=></strong>.</p></li>
<li><p><strong>Exit psql</strong></p>

<pre><code> mydb=&gt; \q
</code></pre></li>
<li><p><strong>Shutdown Database Server</strong></p>

<pre><code> sudo su postgres -c 'pg_ctl -D /opt/local/var/db/postgresql93/defaultdb -l /opt/local/var/log/postgresql/postgres.log stop'
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scala学习笔记]]></title>
    <link href="http://askcuix.github.io/blog/2013/06/16/the-scala-notes/"/>
    <updated>2013-06-16T22:34:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2013/06/16/the-scala-notes</id>
    <content type="html"><![CDATA[<p>断断续续总算是读完了《Scala程序设计 - Java虚拟机多核编程实战》，习惯了Java中规中矩的语言规范，面对这种灵活的语法，着实有点不知所措，之前学习Python的时候，也有过类似的感受，不过这次学习Scala的感觉更强烈点。这本薄薄的不到两百页的书，硬是让我看了个把月，但也总算是对Scala有了初步的认识。对于这本书，只能算是入门书籍，很多东西都只是提到，但讲的不够详细。下面是学习过程中记下来的一些笔记，之后再对一些重要语法详细了解吧。</p>

<h2>val vs. var</h2>

<p>用val定义的变量是不可变的，用var定义的变量是可变的。在Scala中应尽量使用val以提升不变性。</p>

<h2>遍历</h2>

<p>RichInt中的两个方法to和until都返回一个Range的实例。<br/>
<strong>to()</strong> 产生的范围包含了上界和下界。</p>

<pre><code>i &lt;- 1 to 3
</code></pre>

<p><strong>until()</strong> 产生的范围排除上界。</p>

<pre><code>i &lt;- 1 until 3
</code></pre>

<p><strong>foreach()</strong>属于Range类，以一个函数值作为参数。</p>

<pre><code>(1 to 3).foreach(i =&gt; print(i))
</code></pre>

<p><strong>&lt;-</strong> 左边为定义的val变量，右边为生成器表达式。<br/>
<strong>=></strong> 左边为参数列表，右边为实现。</p>

<!-- more -->


<h2>点和括号</h2>

<p>如果方法有0或1个参数，点和括号是可选的，如果参数多于一个，则必须使用括号，但点仍然是可选的。</p>

<pre><code>a+b  --&gt; a.+(b)
1 to 3 --&gt;  1.to(3)
</code></pre>

<h2>元组</h2>

<p>元组是一个不变的对象序列，可用逗号分隔的值进行创建。如：<em>(&#8220;a&#8221;, &#8220;b&#8221;, &#8220;c&#8221;)</em></p>

<p>元组元素可以同时赋给多个var或val。如：<em>val (name, age, sex) = getPerson()</em></p>

<p>将元组赋给数量不一致的变量会出现异常，可以通过<strong>._<seq></strong>来访问单个元素。如：</p>

<pre><code>val info = getPerson();
print(info._1) //first element
print(info._2) //second element
</code></pre>

<h2>字符串</h2>

<p>三个双引号之间的字符串可作为多行字符串。如：<em>&#8221;&#8221;&#8220;multiple line string&#8221;&#8220;&#8221;</em><br/>
多行字符串中允许嵌入双引号，多行字符串会保留字符串的原有格式。<br/>
stripMargin()可用于去除先导符前所有的空白或控制字符，默认先导符为“|”。</p>

<h2>类</h2>

<p>在Scala里，类、字段和方法默认是<strong>public</strong>，无需显示声明。</p>

<p><strong>protected</strong>类只可以由子类访问，且子类只可以访问本类的protected成员。</p>

<p><strong>return</strong>是可选的，方法调用会自动返回最后求值的表达式。若使用了return，则必须显示定义返回类型。</p>

<p>如果用&#8221;<strong>=</strong>&#8220;定义方法，Scala可推演返回类型，否则该方法返回类型为void。</p>

<p>分号是可选的，如果在一行内放置多条语句，可以用分号进行分隔。</p>

<p>方法若没有参数，可以省略方法定义中的括号。若构造函数没有参数，new对象后面的括号也可以省略。</p>

<p>给字段加上<strong>@scala.reflect.BeanProperty</strong>注解，即可以生成JavaBean风格的getter/setter。</p>

<p>Scala默认会导入两个包：<strong>java.lang</strong>和<strong>scala</strong>，和一个对象：<strong>scala.Predef</strong>。</p>

<p>赋值结果是Unit类型，因此不可以多重赋值。如：</p>

<pre><code>a = b  // return Unit, not a
a = b = c // throw error: type mismatch, found Unit, require Int
</code></pre>

<p><strong>==</strong>对所有类型都是基于值的比较，而非引用的比较。<strong>eq()</strong>用于引用的比较。</p>

<p>变量赋值时的“<strong>_</strong>”代表该变量类型的默认值：Int为<em>0</em>，Double为<em>0.0</em>，引用类型为<em>null</em>。</p>

<p>import语句里的“<strong>_</strong>”等价于Java中的“<strong>*</strong>”。如果“_”是跟在类名后，则导入类的所有成员，等价于Java中的static import。</p>

<p>主构造函数放在类定义中，若参数声明为val，则定义为private final类型；若参数声明为var，则定义为private类型；若参数既不是val，也不是var，则创建一个private字段以及private的getter/setter，就不能在类的外部访问该参数。</p>

<p>除主构造函数外，还可以通过<strong>this()</strong>定义两个或多个副构造函数。副构造函数的第一条语句必须是调用主构造函数，或调用另外一个副构造函数。如：</p>

<pre><code>class Person(val firstName: String, val lastName: String) {
    private var gender: String = _


    def this (firstName: String, lastName: String, sex: String) {
         this (firstName, lastName)
         gender = sex
    }
}
</code></pre>

<p>类里定义的var字段会映射为一个private字段，并提供对应的getter/setter，字段上附加的访问权限会加到访问方法getter/setter上。</p>

<p>类继承时，重写方法必须使用<strong>override</strong>关键字，只有主构造函数才能通过override关键字往基类构造函数中传参数。如：</p>

<pre><code>class Vehicle(val id: Int, val year: Int){
    override def toString() : String = "ID: " + id + " Year: " + year
}

class Car(override val id: Int, override val year: Int, var fuelLevel: Int) extends Vehicle(id, year) {
    override def toString() : String = super.toString() + " Fuel Level: " + fuelLevel
}
</code></pre>

<p>创建单例对象要用<strong>object</strong>关键字，而非class。因为单例对象无法初始化，所以不能给主构造函数传递参数。</p>

<pre><code>class Marker(val color: String){
    override def toString() : String = "maker color " + color
}

object MarkerFactory {
   private val markers = Map(
       "red" -&gt; new Marker("red")
   )

   def getMarker(color: String) = if (markers.contains(color)) markers(color) else null
}
</code></pre>

<p>上例中依然可以跳过MarkerFactory，直接创建Marker实例。</p>

<p>在Scala中可以创建一个关联到类上的单例，单例同类共享相同的名字，称为<strong>伴生对象</strong>，对应的类称为<strong>伴生类</strong>。类和伴生对象之间可以互相访问彼此的private字段和方法，可以把类的构造函数标记为private，这样就只可以通过伴生对象获取实例。每个类都可以有伴生对象，它们跟伴生类写在同一个文件中。如：</p>

<pre><code>class Marker private (val color: String){
    override def toString() : String = "maker color " + color
}

object Marker {
   private val markers = Map(
       "red" -&gt; new Marker("red")
   )

   def getMarker(color: String) = if (markers.contains(color)) markers(color) else null
}
</code></pre>

<p>Scala中没有静态字段和静态方法，伴生对象中的字段和方法可作为替代实现。</p>

<p>将创建伴生类的实例方法命名为<strong>apply()</strong>，可以更加容易获取实例，这是Scala提供的语法糖。在上例中需要通过 <em>Marker getMarker &#8220;red&#8221;</em> 来获取，若将getMarker改名为apply，则可以直接通过<em>Marker(&#8220;red&#8221;)</em>来获取。</p>

<pre><code>def apply(color: String) = if (markers.contains(color)) markers(color) else null
</code></pre>

<h3>Nothing</h3>

<p>Nothing是所有类的子类。</p>

<h3>Any</h3>

<p>Any是所有类的父类。Any的直接子类是AnyVal和AnyRef，AnyVal是所有可以映射为Java基本类型的类的父类，AnyRef是所有引用类型的父类，可直接映射为Java的Object。</p>

<h3>Option</h3>

<p>用于强制检查实例是否存在。getOrElse()可处理结果不存在的情况。</p>

<h2>可变参数(vararg)</h2>

<p>方法参数在类型之后使用“*”，则标识该参数为可变数目实参。可变参数会当作数组处理，但不可传入数组作为实参。若相使用数组中的值作为可变实参，可以使用“<strong>_*</strong>”展开数组。如：</p>

<pre><code>def max(values: Int*) = values.foldLeft(values(0)) { Math.max }
val numbers = Array(2, 4, 3, 7, 6)
println(max(numbers: _*))
</code></pre>

<h2>参数化类型(Parameterized Type)</h2>

<p>Scala使用“<strong>&lt;:</strong>”来定义参数化类型。如 <em>T&lt;:Pet</em> 表示T为Pet的子类。也可以使用“<strong>>:</strong>”，如 <em>T>:Dog</em> 表示T为Dog的父类。</p>

<pre><code>def playWithPets[T &lt;: Pet](pets: Array[T]) = println("……….")
</code></pre>

<p>参数化类型使用“<strong>+T</strong>”表示允许协变，即可接收某个类型或其父类。</p>

<p>参数化类型使用”<strong>-T</strong>“表示允许逆变，即可接收某个类型或其子类。</p>

<h2>Curry化</h2>

<p>将函数从接收多个参数转变为接收多个参数列表，以减少传递函数值。如：</p>

<p>原函数：</p>

<pre><code>def foo(a: Int, b: Int, operation: (Int, Int) =&gt; Int) ： Int = {}
</code></pre>

<p>Curry化：</p>

<pre><code>def foo(a: Int)(b: Int)(operation: (Int, Int) =&gt; Int) : Int = {}
</code></pre>

<p>调用如下，函数值不需要以参数的形式写在括号中了，这种形式更优雅。</p>

<pre><code>val sum = foo(1)(2) { (c, d) =&gt; c + d}
</code></pre>

<h2>Trait</h2>

<p>Trait里定义和初始化的val和var会在混入trait的类的内部得到实现。如果类没有继承其它类，则可以使用<strong>extends</strong>关键字混入trait；如果类已继承了其它类，则可以使用<strong>with</strong>关键字混入一个或多个trait。</p>

<pre><code>trait Friend {
    val name: String
    def listen() = println("Your friend " + name + " is listening")
}

class Human(val name: String) extends Friend

class Dog(val name: String) extends Animal with Friend
</code></pre>

<p>Trait会被编译成Java的接口，还有对应的实现类，里面包含了trait已实现的方法。</p>

<p>Trait需要混入类实现未初始化的变量和值，trait的构造器不能有任何参数。</p>

<p>Trait也可以在实例中进行混入。如：</p>

<pre><code>class Cat(val name: String) extends Animal

val snowy = new Cat("Snowy") with Friend
</code></pre>

<p>当Trait用于装饰对象时，trait只能混入继承自trait父类的类。在trait里，super并不是对基类的调用，而是对其左边混入的trait的调用，如果这个trait已经是最左的trait，则调用就会解析成混入这个trait的类的方法。</p>

<pre><code>abstract class Check {
    def check() : String = "Checked Details…..."
}

trait CreditCheck extends Check {
    override def check() : String = "Checked Credit……" + super.check()
}

trait EmploymentCheck extends Check {
    override def check() : String = "Checked Employment….." + super.check()
}

val emplomentApp = new Check with EmploymentCheck with CreditCheck
println(emplomentApp check)
</code></pre>

<p>打印结果：</p>

<p><em>Checked Credit……Checked Employment….Checked Details……</em></p>

<p>若trait的基类的方法是抽象的，则trait在继承这个类时，需要将该方法声明为abstract override。这个方法的最终实现由混入这个trait的类提供。</p>

<pre><code>abstract class Writer {
    def writeMessage(message: String)
}

trait UpperCaseWriter extends Writer {
    abstract override def writeMessage(message: String) = super.writeMessage(message.toUpperCase)
}

class StringWriterDelegate extends Writer {
    val writer = new java.io.StringWriter

    def writeMessage(message: String) = writer.write(message)
    override def toString() : String = writer.toString 
}

val writerTest = new StringWriterDelegate with UpperCaseWriter
writerTest writeMessage "String writer test"
println(writerTest)
</code></pre>

<p>打印结果：</p>

<p><em>STRING WRITER TEST</em></p>

<h2>隐式转换</h2>

<p>若需转换数据类型，可定义一个转换方法，并将该方法标记为implicit，该方法需要在变量使用的当前范围内可见（通过当前import可见，或位于当前文件）。</p>

<p>在Predef对象中，Scala已经定义了一些隐式转换，且默认导入它们。Scala一次最多应用一个隐式转换。</p>

<h2>集合类</h2>

<p>Scala的集合类包括：<strong>List</strong>, <strong>Set</strong>和<strong>Map</strong>，除了List外，其它两种集合同时提供了可变和不可变的两个版本，默认使用不可变的集合类。Predef对象为集合类提供的别名指向不可变的实现。</p>

<p>可变版本：<em>scala.collection.mutable</em><br/>
不可变版本：<em>scala.collection.immutable</em></p>

<p>若需要修改集合且对集合的所有操作都在一个线程里，则可以选择可变集合类。</p>

<p><strong>_</strong>：用于表示遍历集合时的每个元素。</p>

<h3>Set</h3>

<p><strong>filter()</strong>：用于过滤Set中的数据。<br/>
<strong>mkString()</strong>：为Set中的每个元素创建了字符串，然后用参数字符串将结果连接起来。与apache common-lang中StringUtils的join方法作用相同。<br/>
<strong>++()</strong>：合并两个Set成一个新的Set。<br/>
<strong>**()</strong>：执行交集运算。<br/>
<strong>map()</strong>：对每个元素应用给定的函数值，将结果收集到一个新的Set中。<br/>
<strong>toArray()</strong>：将Set中的元素复制到数组中，以通过索引来访问Set中的元素。<br/>
<strong>foreach()</strong>：迭代Set中的元素。</p>

<h3>Map</h3>

<p>key与value之间使用<strong>-></strong>。如：<em>val feeds = Map(&#8220;Scala&#8221; -> &#8220;www.scala-lang.org&#8221;)</em></p>

<p><strong>filterKeys()</strong>：对Key进行过滤。<br/>
<strong>filter()</strong>：对Key和Value进行过滤。提供给filter()的函数值接收一个(key, value)元组。如：</p>

<pre><code>val result = feeds filter { element =&gt; 
    val (key, value) = element 
    (key startsWith "S") &amp;&amp; (value contains "lang") 
}
</code></pre>

<p><strong>get()</strong>：用给定的Key获取Value。由于给定的Key可能没有对应的Value，所以该方法的返回类型是Option[T]，结果可能是Some[T]或None，T为Value的类型。<br/>
<strong>apply()</strong>：对类或对象使用括号时，即调用该方法。用于获取给定Key对应的Value，若没有对应的Value，则抛出异常，应将该方法放在try-catch中。<br/>
<strong>update()</strong>：更新Map，并返回一个新的Map。有一种简写的方式：X() = b，等价于X.update(b)，若参数多于一个，则将最后一个参数之外的所有参数放在括号里，X(a) = b 等价于X.update(a, b)。也可以将Map定义为可变容器scala.collection.mutable.Map，则可以直接更新。</p>

<h3>List</h3>

<p>List只有不可变实现。</p>

<p><strong>head()</strong>：可快速访问List的第一个元素。<br/>
<strong>tail()</strong>：用于访问第一个元素之外的其它元素。访问最后一个元素需要遍历List，因此相比较head()，该操作的代价较大。<br/>
<strong>::()</strong>：将元素添加在第一个元素之前。a :: list，即在list前添加a。该方法的完整表示：<em>list.::(a)</em>。<br/>
<strong>:::()</strong>：将一个list附加到另一个list之前。<em>list ::: listA</em>，即在listA前添加list。由于List是不可变的，所以这两个List都不会改变，会创建一个新的List并返回。将一个元素或List添加到另一个List的后面，实际上是调用后面那个List的前缀运算符，由于访问List的头元素比遍历到最后一个元素快的多，因此这种方式的性能会更好。<br/>
<strong>filter()</strong>：对List进行过滤。<br/>
<strong>forall()</strong>：检查List中的元素是否都满足指定的条件。<br/>
<strong>exists()</strong>：检查List中是否存在满足指定条件的元素。<br/>
<strong>map()</strong>：对每个元素应用给定的函数值，将结果收集到一个新的List中。 <br/>
<strong>mkString()</strong>：将List中的元素用参数字符串连接起来。与apache common-lang中StringUtils的join方法作用相同。<br/>
<strong>foldLeft()</strong>：从List的最左端开始为每个元素调用给定的函数值。它会传递两个参数给函数值，第一个参数是对之前元素执行函数值的部分结果，初始值为方法的参数，第二个参数是List的元素。该方法的另一种表示：<strong>/:()</strong>。</p>

<pre><code>val total = feeds.foldLeft(0) { (total, feed) =&gt; total + feed.length }
</code></pre>

<p>等价于</p>

<pre><code>val total = (0 /: feeds) { (total, feed) =&gt; total + feed.length }
</code></pre>

<p><strong>foldRight()</strong>：与foldLeft()的操作相同，但是从List的最右端开始。该方法的另一种表示：<strong>\:()</strong>。</p>

<h2>case表达式</h2>

<p>case表达式通常与match一起使用做模式匹配。case会按照顺序自上而下进行比较。</p>

<p><strong>_</strong>用作通配符，在所有指定的case都不匹配的情况下，作为默认处理，否则会抛出MatchError异常。</p>

<p><strong>_*</strong>用作匹配List时，除去指定元素之外的所有元素。若需要引用这些元素，可以用@放在_*和变量名之间，如：</p>

<pre><code>case List("apple", "orange", otherFruits @ _*) =&gt; println("apples, oranges, and " + otherFruits)
</code></pre>

<p>case语句可以根据类型进行匹配，还可以使用guard语句，用if从句表示。</p>

<pre><code>def process(input: Any) {
    input match {
         case (a: Int, b: Int) =&gt; print("Processing (int, int)…..")
         case (a: Double, b: Double) =&gt; print("Processing (double, double)…..")
         case msg : Int if (msg &gt; 1000) =&gt; print("Processing int &gt; 1000")
         case msg : Int =&gt; print("Processing int…..")
         case _ =&gt; printf("Can't handle %s… ", input)
    }
}
</code></pre>

<p>case表达式中，模式变量要以小写字母开头，常量要以大写字母开头，否则无法通过编译。</p>

<p><strong>sealed abstract</strong>用于告知Scala除该文件中已有的类之外，不会再有其它的类作为case类。若case表达式没有包含所有的case类，则会在编译时遇到warning。</p>

<p>case类若没有参数，在调用case表达式的方式时，也需要使用括号。否则参数就不是case类的实例，而是它的伴生对象。</p>

<p>定义Extractor可以在case表达式中匹配任意模式。unapply()方法用于接收要匹配的值。Extractor方法中的参数并不是传入的实参，而是用于接收从方法中返回的值。Extractor方法中的参数还可以引用另外一个Extractor方法用以验证返回的值，在参数和调用的Extractor方法之间使用@符合。</p>

<h2>正则表达式</h2>

<p>使用<em>scala.util.matching</em>包中的<strong>Regex</strong>类的实例进行匹配。</p>

<p>String的<strong>r()</strong>方法会将String转换成RichString，然后调用该方法并返回Regex实例。</p>

<p>正则表达式可直接在case表达式中作为Extractor使用。正则表达式中每个放在括号里的匹配都展开到一个模式变量中，如：<em>&#8220;(S|s)cala&#8221;.r</em>的unapply()方法会返回Option[String]，<em>&#8220;(S|s)(cala)&#8221;.r</em>的unapply()方法会返回Option[String, String]。</p>

<p><strong>findFirstIn()</strong>：用于查找第一个正则表达式的匹配。<br/>
<strong>findAllIn()</strong>：用于查找正则表达式的所有匹配，并返回List结果。<br/>
<strong>replaceFirstIn()</strong>：用于替换第一个正则表达式的匹配。<br/>
<strong>replaceAllIn()</strong>：用于替换所有正则表达式的匹配。</p>

<h2>actor模型</h2>

<p>actor提供了一种基于事件的轻量级线程。使用<em>scala.actors.Actor</em>伴生对象的<strong>actor()</strong>方法就可以创建一个actor。它接受一个函数值/闭包做参数，一创建好就开始运行。用<strong>!()</strong>方法给actor发消息，用<strong>reveive()</strong>方法从actor接收消息，通常用模式匹配处理接收到的消息。</p>

<p>Scala的Actor是个trait，混入Actor的类必须实现<strong>act()</strong>。start()方法用于启动actor并调用act()方法，没启动之前给actor发送的消息会进入队列。exit()方法用于停止actor，该方法会抛出异常，以终止当前线程的执行。</p>

<p>如果无需控制何时启动actor，则可以使用actor()方法创建actor。在actor中将消息委托给另一个actor，可以并发的处理多个请求。</p>

<p>receive()会造成程序阻塞，指导收到应答为止。receiveWithin()方法接收一个timeout参数，若超时时限内未收到消息，receiveWithin()会收到一个TIMEOUT消息。</p>

<p>使用<strong>SingleThreadedScheduler</strong>可以让Scala在主线程里运行actor，通过设置 <em>Scheduler.impl = new SingleThreadedScheduler</em>，就可以控制整个应用的actor调度策略。通过继承Actor trait，并改写scheduler()方法，可以控制线程是否运行在主线程中。</p>

<h2>与Java互操作</h2>

<p>若要在编译过的Scala或Java代码里使用Scala类，则必须编译Scala文件。</p>

<p>若Java代码中的方法或字段的名字与Scala的关键字有冲突，在调用时会导致Scala编译器死掉。可将冲突的变量名或方法名放在反引号中，以避免该问题。</p>

<p>Java暂不支持闭包，因此若Scala要提供给Java使用，则应避免使用闭包，或同时提供普通函数。</p>

<p>trait若没有方法实现，则可在Java中当作接口使用；若trait中有方法实现，则只可以在Java中持有该引用。</p>

<p>Scala的单例对象，在Java中可以像有static方法的Java类一样使用。</p>

<p>Scala会为同名类的伴生对象创建两个类，若类名为Buddy，则一个伴生类Buddy，和一个伴生对象类Buddy$。在Java中访问伴生类可以直接使用类的名字，访问伴生对象则需要使用MODULE$，如Buddy$.MODULE$。</p>

<p>Scala不支持throws，若Java中继承的Scala方法会抛出异常，就需要在Scala的方法前定义注解@throws。</p>

<h2>Resources</h2>

<p>IBM developerWorks Scala 指南：<a href="http://www.ibm.com/developerworks/cn/java/j-scala/">http://www.ibm.com/developerworks/cn/java/j-scala/</a><br/>
Programming Scala：<a href="http://ofps.oreilly.com/titles/9780596155957/">http://ofps.oreilly.com/titles/9780596155957/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Redis Introduction]]></title>
    <link href="http://askcuix.github.io/blog/2013/06/13/the-redis-introduction/"/>
    <updated>2013-06-13T23:45:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2013/06/13/the-redis-introduction</id>
    <content type="html"><![CDATA[<p>Redis是<strong>RE</strong>mote <strong>DI</strong>ctionary <strong>S</strong>erver的缩写，它采用了单请求处理线程的架构，避免了管理并发的复杂问题，也简化了实现，但同时也带来CPU的瓶颈，当单线程被阻塞时整个Redis都会停止响应。</p>

<h2>Redis Key</h2>

<p>Key不能太长，推荐的格式为：<em>&lt;object type>:&lt;id>:&lt;field></em>，用“<strong>:</strong>”分隔域，用“<strong>.</strong>”作为单词间的连接。</p>

<p>KEYS命令可返回匹配指定模式的key，模式支持通配符，具体可参考：<a href="http://redis.readthedocs.org/en/latest/key/keys.html">http://redis.readthedocs.org/en/latest/key/keys.html</a></p>

<p>SORT命令可对集合按数字或字母顺序排序后返回或另存为list，还可以关联到外部key等。可参考：<a href="http://redis.readthedocs.org/en/latest/key/sort.html">http://redis.readthedocs.org/en/latest/key/sort.html</a></p>

<p>Key超时操作常用的命令：<a href="http://redis.readthedocs.org/en/latest/key/expire.html">EXPIRE</a>、<a href="http://redis.readthedocs.org/en/latest/key/expireat.html">EXPIREAT</a>、<a href="http://redis.readthedocs.org/en/latest/key/persist.html">PERSIST</a>、<a href="http://redis.readthedocs.org/en/latest/key/ttl.html">TTL</a>。</p>

<p>其它关于Key的常用命令：<a href="http://redis.readthedocs.org/en/latest/key/exists.html">EXISTS</a>、<a href="http://redis.readthedocs.org/en/latest/key/del.html">DEL</a>、<a href="http://redis.readthedocs.org/en/latest/key/randomkey.html">RANDOMKEY</a>、<a href="http://redis.readthedocs.org/en/latest/key/rename.html">RENAME</a>、<a href="http://redis.readthedocs.org/en/latest/key/renamenx.html">RENAMENX</a>、<a href="http://redis.readthedocs.org/en/latest/key/type.html">TYPE</a>。</p>

<!-- more -->


<h2>Redis Value的数据结构</h2>

<h3>String</h3>

<p>可以是任何种类的字符串（包括二进制数据），长度不能超过1GB。</p>

<p>除了最基本的GET/SET，Redis还提供了一些简便的指令。</p>

<p><a href="http://redis.readthedocs.org/en/latest/string/incr.html">INCR</a>/<a href="http://redis.readthedocs.org/en/latest/string/decr.html">DECR</a>/<a href="http://redis.readthedocs.org/en/latest/string/incrby.html">INCRBY</a>/<a href="http://redis.readthedocs.org/en/latest/string/incrbyfloat.html">INCRBYFLOAT</a>/<a href="http://redis.readthedocs.org/en/latest/string/decrby.html">DECRBY</a>：针对数字类型的字符串。若key不存在时创建key并设值为0。INCRBYFLOAT专门针对float类型的值，使用负数即可实现DECR的效果。</p>

<p><a href="http://redis.readthedocs.org/en/latest/string/setex.html">SETEX</a>：即Set + Expire。</p>

<p><a href="http://redis.readthedocs.org/en/latest/string/setnx.html">SETNX</a>：即SET if Not eXists。</p>

<p><a href="http://redis.readthedocs.org/en/latest/string/getset.html">GETSET</a>：设置新值，并返回旧值。</p>

<p><a href="http://redis.readthedocs.org/en/latest/string/mget.html">MGET</a>/<a href="http://redis.readthedocs.org/en/latest/string/mset.html">MSET</a>/<a href="http://redis.readthedocs.org/en/latest/string/msetnx.html">MSETNX</a>：GET/SET/SETNX的批量操作。</p>

<p><a href="http://redis.readthedocs.org/en/latest/string/getbit.html">GETBIT</a>/<a href="http://redis.readthedocs.org/en/latest/string/setbit.html">SETBIT</a>/<a href="http://redis.readthedocs.org/en/latest/string/bitop.html">BITOP</a>/<a href="http://redis.readthedocs.org/en/latest/string/bitcount.html">BITCOUNT</a>：Redis BitMap的用法，使用场景可参考：<a href="http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps/">http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps/</a>。</p>

<p><a href="http://redis.readthedocs.org/en/latest/string/append.html">APPEND</a>/<a href="http://redis.readthedocs.org/en/latest/string/setrange.html">SETRANGE</a>/<a href="http://redis.readthedocs.org/en/latest/string/getrange.html">GETRANGE</a>/<a href="http://redis.readthedocs.org/en/latest/string/strlen.html">STRLEN</a>：对字符串进行扩展、替换、截取和取长度，只适用于特定数据格式的字符串。</p>

<h3>Hash</h3>

<p>Key-HashMap结构，可以一次set，get多个属性。相比JSON格式的字符串，可以只读取/更新对象的某些属性，不用取回所有的属性，改完再写回去。</p>

<p>可以通过该数据结构建立索引。比如User对象，通常都会使用id或name来查询，这样在插入User对象时：<em>set user:101 {&#8220;id&#8221;:101,&#8221;name&#8221;:&#8221;admin&#8221;}</em>， 同时再插入一条hash结构的索引：<em>hset user:index:name admin 101</em>。按name查询的时候，使用：<em>hget user:index:name admin</em> 就能取出对应的id。</p>

<h3>List</h3>

<p>List是一个双向链表，基于linked list，支持双向的Pop/Push，一般从左端Push，右端Pop。在左端或右端添加一个元素的复杂度是一样的。</p>

<p>List的下标从0开始，从左到右计算，下标为负数时则从右到左。</p>

<p>常用的命令：</p>

<p><a href="http://redis.readthedocs.org/en/latest/list/lrem.html">LREM</a>：按值删除元素。<br/>
<a href="http://redis.readthedocs.org/en/latest/list/linsert.html">LINSERT</a>：插在某个值的前后。<br/>
<a href="http://redis.readthedocs.org/en/latest/list/lset.html">LSET</a>：按下标设置元素值。<br/>
<a href="http://redis.readthedocs.org/en/latest/list/lindex.html">LINDEX</a>：按下标返回元素。<br/>
<a href="http://redis.readthedocs.org/en/latest/list/lrange.html">LRANGE</a>：返回列表内一段下标的元素，可用于分页操作。<br/>
<a href="http://redis.readthedocs.org/en/latest/list/ltrim.html">LTRIM</a>：限制List的大小。   <br/>
<a href="http://redis.readthedocs.org/en/latest/list/blpop.html">BLPOP</a>/<a href="http://redis.readthedocs.org/en/latest/list/brpop.html">BRPOP</a>：阻塞版的pop命令，可用于Message Queue，当多个Client并发阻塞等待，有Element入列时谁先被阻塞谁先被服务。</p>

<h3>Set</h3>

<p>用于存储不重复的值，无序。还提供一些交集，并集，差集的集合操作。</p>

<p><a href="http://redis.readthedocs.org/en/latest/set/sadd.html">SADD</a>/<a href="http://redis.readthedocs.org/en/latest/set/srem.html">SREM</a>/<a href="http://redis.readthedocs.org/en/latest/set/sismember.html">SISMEMBER</a>/<a href="http://redis.readthedocs.org/en/latest/set/scard.html">SCARD</a>/<a href="http://redis.readthedocs.org/en/latest/set/smove.html">SMOVE</a>/<a href="http://redis.readthedocs.org/en/latest/set/smembers.html">SMEMBERS</a>：基本操作。
<a href="http://redis.readthedocs.org/en/latest/set/sinter.html">SINTER</a>/<a href="http://redis.readthedocs.org/en/latest/set/sinterstore.html">SINTERSTORE</a>/<a href="http://redis.readthedocs.org/en/latest/set/sunion.html">SUNION</a>/<a href="http://redis.readthedocs.org/en/latest/set/sunionstore.html">SUNIONSTORE</a>/<a href="http://redis.readthedocs.org/en/latest/set/sdiff.html">SDIFF</a>/<a href="http://redis.readthedocs.org/en/latest/set/sdiffstore.html">SDIFFSTORE</a>：集合操作。</p>

<h3>Sorted Set</h3>

<p>有序集合，元素放入集合时要提供该元素的分数。</p>

<p><a href="http://redis.readthedocs.org/en/latest/sorted_set/zrange.html">ZRANGE</a>/<a href="http://redis.readthedocs.org/en/latest/sorted_set/zrevrange.html">ZREVRANGE</a>：按排名的上下限返回元素，正数与倒数。<br/>
<a href="http://redis.readthedocs.org/en/latest/sorted_set/zrangebyscore.html">ZRANGEBYSCORE</a>/<a href="http://redis.readthedocs.org/en/latest/sorted_set/zrevrangebyscore.html">ZREVRANGEBYSCORE</a>：按分数的上下限返回元素，正数与倒数。<br/>
<a href="http://redis.readthedocs.org/en/latest/sorted_set/zremrangebyrank.html">ZREMRANGEBYRANK</a>/<a href="http://redis.readthedocs.org/en/latest/sorted_set/zremrangebyscore.html">ZREMRANGEBYSCORE</a>：按排名/分数的上下限删除元素。<br/>
<a href="http://redis.readthedocs.org/en/latest/sorted_set/zcount.html">ZCOUNT</a>：统计分数上下限之间的元素个数。<br/>
<a href="http://redis.readthedocs.org/en/latest/sorted_set/zrank.html">ZRANK</a>/<a href="http://redis.readthedocs.org/en/latest/sorted_set/zrevrank.html">ZREVRANK</a>：显示某个元素的正倒序的排名。<br/>
<a href="http://redis.readthedocs.org/en/latest/sorted_set/zscore.html">ZSCORE</a>/<a href="http://redis.readthedocs.org/en/latest/sorted_set/zincrby.html">ZINCRBY</a>：显示元素的分数/增加元素的分数。<br/>
<a href="http://redis.readthedocs.org/en/latest/sorted_set/zadd.html">ZADD</a>/<a href="http://redis.readthedocs.org/en/latest/sorted_set/zrem.html">ZREM</a>/<a href="http://redis.readthedocs.org/en/latest/sorted_set/zcard.html">ZCARD</a>/<a href="http://redis.readthedocs.org/en/latest/sorted_set/zinterstore.html">ZINSERTSTORE</a>/<a href="http://redis.readthedocs.org/en/latest/sorted_set/zunionstore.html">ZUNIONSTORE</a>：集合操作，与Set相比，少了IsMember和差集运算。</p>

<h2>事务</h2>

<p>用<strong>MULTI</strong>(Start Transaction)、<strong>EXEC</strong>(Commit)、<strong>DISCARD</strong>(Rollback)实现。 在事务提交前，不会执行任何指令，只会把它们存到一个队列里。此时其他客户端可以对当前数据进行任意的操作。在事务提交时，批量执行所有指令，因为是单线程架构，在执行完事务内所有指令前是不可能再去同时执行其他客户端的请求的。</p>

<p>Redis不保证所有指令同时成功或失败，只有决定是否开始执行全部指令的能力，没有执行到一半进行回滚的能力。</p>

<p><strong>WATCH</strong>命令在事务提交时，如果Key的值已被别的客户端改变，则整个事务队列都不会被执行。</p>

<h2>持久化</h2>

<p>RDB与AOF完全独立运行。只有正确关闭服务器：<em>redis-cli shutdown</em>，才保证写RDB文件以及将AOF文件fsync到磁盘，不会丢失数据。 如果是<em>Ctrl+C</em>，或者 <em>kill -9</em> 就可能丢失。</p>

<h3>RDB</h3>

<p>整个内存的压缩过的Snapshot，可以配置复合的重写触发条件，默认是1分钟内改了1万次，或5分钟内改了10次，或15分钟内改了1次。</p>

<p>先写到临时文件再重命名，这样外部程序对RDB文件的备份和传输过程是安全的。而且即使写新快照的过程中Server被强制关掉了，旧的RDB文件还在。</p>

<p>可配置是否进行压缩，压缩方法是字符串的LZF算法，以及将string形式的数字变回int形式存储。</p>

<h3>AOF</h3>

<p>append only的操作日志，记录所有有效的写操作，格式就是Redis协议的纯文本文件。</p>

<p>如果使用了AOF，重启时只会从AOF文件载入数据，不会再管RDB文件。</p>

<p>RDB不会实时写入数据，而且如果同时使用两者，但服务器重启只会找AOF文件。不建议只使用AOF，因为RDB更适合用于备份数据库，快速重启。</p>

<h2>Windows版本</h2>

<p>Redis本身并未提供Windows版本，微软技术小组采用LibUV成功将Redis移植到了windows平台，这样就方便了应用的本地开发调试。</p>

<p>目前的稳定版是2.6版本，支持Lua脚本：<a href="https://github.com/MSOpenTech/redis">https://github.com/MSOpenTech/redis</a></p>

<p>编译好的可执行文件：<a href="https://github.com/MSOpenTech/redis/tree/2.6/bin/release">https://github.com/MSOpenTech/redis/tree/2.6/bin/release</a></p>

<h2>Resources</h2>

<p>Redis的设计与实现：<a href="http://www.redisbook.com/en/latest/">http://www.redisbook.com/en/latest/</a><br/>
The Little Redis Book：<a href="http://openmymind.net/2012/1/23/The-Little-Redis-Book/">http://openmymind.net/2012/1/23/The-Little-Redis-Book/</a><br/>
Redis 命令参考：<a href="http://redis.readthedocs.org/en/latest/">http://redis.readthedocs.org/en/latest/</a> <br/>
NoSQLFan - Redis资料汇总专题：<a href="http://blog.nosqlfan.com/html/3537.html">http://blog.nosqlfan.com/html/3537.html</a><br/>
Redis响应延迟问题排查：<a href="http://www.oschina.net/translate/redis-latency-problems-troubleshooting">http://www.oschina.net/translate/redis-latency-problems-troubleshooting</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac使用技巧]]></title>
    <link href="http://askcuix.github.io/blog/2013/06/09/the-mac-tips/"/>
    <updated>2013-06-09T15:11:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2013/06/09/the-mac-tips</id>
    <content type="html"><![CDATA[<p>一些常用的Mac使用技巧，记下来以方便查阅。</p>

<h2>文件管理</h2>

<p><strong>删除文件</strong>：command+delete</p>

<p><strong>清空废纸篓(有确认)</strong>：shift+command+delete</p>

<p><strong>清空废纸篓(无确认)</strong>：shift+option+command+delete</p>

<p><strong>打开文件</strong>：command+o</p>

<p><strong>全屏幕截图(图片默认存放在桌面)</strong>：shift+command+3</p>

<p><strong>鼠标选取截图(图片默认存放在桌面)</strong>：shift+command+4</p>

<p><strong>选取文本</strong>：用command+鼠标，可以选中不同位置的文本内容。 用option+鼠标，可以对文本进行块选。</p>

<p><strong>粘贴纯文本</strong>：我们在网页或其他文档上复制文字的时候，会把文字格式一并复制下来，command+v会把文字格式都粘贴过去，如果我们只想粘贴纯文本，可以使用shift+option+command+v。</p>

<p><strong>定位Spotlight搜索结果的文件夹</strong>：用Spotlight搜索的时候，搜到文件时，若需要打开该文件所在的文件夹，只需按住command键，点击文件即可打开Finder，并定位到该文件所在文件夹。</p>

<!-- more -->


<h2>字符输入</h2>

<p><strong>美元$</strong>：shift+4<br/>
<strong>美分¢</strong>：option+4<br/>
<strong>英镑£</strong>：option+3<br/>
<strong>人民币¥</strong>：option+y<br/>
<strong>欧元€</strong>：shift+option+2<br/>
<strong>波折号–</strong>：option+-或shift+option+-<br/>
<strong>省略号…</strong>：option+;<br/>
<strong>约等于≈</strong>：option+x<br/>
<strong>度°</strong>：shift+option+8<br/>
<strong>除号÷</strong>：option+/<br/>
<strong>无穷大∞</strong>：option+5<br/>
<strong>小于等于≤</strong>：option+,<br/>
<strong>大于等于≥</strong>：option+.<br/>
<strong>不等于≠</strong>：option+=<br/>
<strong>圆周率Piπ</strong>：option+p<br/>
<strong>正负±</strong>：shift+option+=<br/>
<strong>平方根√</strong>：option+v<br/>
<strong>总和∑</strong>：option+w<br/>
<strong>商标Trademark™</strong>：option+2<br/>
<strong>注册®</strong>：option+r<br/>
<strong>版权©</strong>：option+g<br/>
<strong>苹果标志</strong>：option+shift+k</p>

<h2>系统管理</h2>

<p><strong>du -sh *</strong>：查看某个目录下各个文件和子目录所占空间大小。</p>

<p><strong>top</strong>：显示目前系统的进程情况、CPU使用情况、内存使用情况、磁盘使用情况和进程的详细列表等信息，输入? 会显示帮助信息，可以自定义top显示的信息，q退出监控界面。</p>

<p><strong>查看电源的详细信息</strong>：按住option键，点击左上角的苹果－系统信息，在打开窗口的左侧栏中找到电源，点击即可查看电源的详细信息，主要的指标包括电池循环计数、状况等信息。</p>

<p><strong>启用F功能键</strong>：打开系统偏好设置-键盘，选中“将 F1、F2 等键用作标准功能键”，启用此选项时，顶部一行按键将用作标准功能键 (F1 - F12)，而不执行音量控制等特殊功能。启用此选项后，若要使用这些按键的特殊功能，请按fn，比如请fn+f8来播放音乐。</p>

<p><strong>执行root权限</strong>：在命令之前增加sudo指令，系统会提示你输入用户密码，执行root权限。</p>

<p><strong>启用root用户</strong>：打开Finder，输入shift+command+g，在前往文件夹中输入：/System/Library/CoreServices，然后在目录中找到目录实用工具并打开，解开左下角的小锁，然后点击顶部编辑菜单，就会看到启用或停用root用户的选项了。然后我们在命令行下执行su -，就可以切换到root目录下，root的默认目录是/var/root。</p>

<h2>日常使用</h2>

<p><strong>调节音量(无“啵啵”声)</strong>：shift+音量调节按钮。</p>

<p><strong>最小音量</strong>：将音量调节减到(F11)静音，然后按静音(F10)调节静音或最小音量。</p>

<p><strong>无确认窗口</strong>：按住option，再点关机、重启、注销时，就不会弹出确认窗口。</p>

<p><strong>选择资料库</strong>：按住option，再打开itunes、iphoto等软件，可以打开选择资料库的对话框。</p>

<p><strong>关闭所有窗口</strong>：command+option+w。</p>

<p><strong>复制文件</strong>：按住option拖拽文件。</p>

<p><strong>创建替身</strong>：按住option+command拖拽文件。</p>

<h2>MAC命令</h2>

<p>显示隐藏文件：</p>

<pre><code>defaults write com.apple.finder AppleShowAllFiles -bool YES
</code></pre>

<p>恢复隐藏文件不可见：</p>

<pre><code>defaults write com.apple.finder AppleShowAllFiles -bool NO
</code></pre>

<p>重启Finder：</p>

<pre><code>killall Finder
</code></pre>

<h2>TextMate</h2>

<p><strong>转换字符为大写</strong>：control+u<br/>
<strong>转换字符为小写</strong>：control+shift+u</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[XML文件比较工具]]></title>
    <link href="http://askcuix.github.io/blog/2013/06/01/the-tool-for-xml-compare/"/>
    <updated>2013-06-01T17:27:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2013/06/01/the-tool-for-xml-compare</id>
    <content type="html"><![CDATA[<p>最近公司的新产品准备上线，因为涉及到多个系统之间的集成，所以要做几轮的模拟测试，以保证系统间的稳定运行以及数据的准确性。对于其中一个Batch Job，我们需要生成多种XML给其它系统使用，这个Batch并不是全新的，在之前的版本就有，但是这次数据模型有变动，一些业务逻辑也有少许变动，但期望生成的数据是一样的，所以就需要比较两个版本的系统所生成的XML。</p>

<p>现在真是越来越不喜欢XML，超过30M的文件，基本就不可能用NotePad++打开了（与我的机器配置太差也有关系）。通常对于一些小的文件，还可以用Beyond Compare之类的比较工具，而我们Batch生成的XML文件可能会超过100M，那就不可能通过一些桌面软件去做比较了，而且数量太大，肉眼比较的准确性也不能保证。<!-- more -->这些XML文件中主要是金融产品信息，由于在生成文件的时候并没有做排序，因此每次生成的文件中，产品的顺序可能也是不同的，这样就更难用比较工具了。</p>

<p>对于这种情况，只能自己去写个比较工具了，在网上找了一下，也没找到满足要求的，现在代码已经完成，放在<a href="https://github.com/askcuix/xml-compare-tool">GitHub</a>,可以生成比较详细的统计信息，如XML中的record数量，不同record的数量，不相同的field，处理时间等。在我那台破机器上，比较两个150M的文件，可以在两分钟内完成。</p>

<p>具体的用法可项目的主页上已经有描述了，这里简单说下实现的思路，因为实现的比较匆忙，有很多考虑不周的地方。实现的步骤如下：</p>

<ol>
<li>通过SAX解析将源文件解析成一个Map，key为产品ID，可以为一个或多个element组合而成，value为该产品所对应的XML内容。</li>
<li>仍然通过SAX解析待比较的文件，每解析出一个产品信息，就从之前的Map中取出相同的产品信息，这时就得到了相同产品的两个版本的内容。如果产品只存在于待比较的文件中，则计入不同record的数量。</li>
<li>使用DOM解析两个XML片段，结果放在两个Map中，key为element的名字，value的element的值。这里需要考虑几种情况：如果element是可选的，则可能只出现在其中一个XML片段中；如果element是重复性的组合元素，则当作一个field。</li>
<li>在比较的过程中，每比较完一个XML片段就删除引用，以达到在内存不够时，可以通过GC释放内存。</li>
<li>当比较结束，第一步产生的Map中若还有产品存在，则为待比较的文件中没有的产品，计入不同record的数量。</li>
<li>统计比较结果，一并写入文件中。</li>
</ol>


<p>暂时未考虑到更好的有效利用内存的方法，对于比较重复性的element，现在是通过配置来识别，一直在纠结要不要通过解析XSD来实现，但这种方式既增加了代码的复杂性，也很难去处理不同级别的重复性元素，比如root element是productList，下一级就是重复性的元素product,对于这种情况，是不应当视为重复性元素来处理的。</p>

<p>改进还要继续，提供给更多有相似需求的人使用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git常用命令]]></title>
    <link href="http://askcuix.github.io/blog/2013/05/27/the-git-command/"/>
    <updated>2013-05-27T23:35:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2013/05/27/the-git-command</id>
    <content type="html"><![CDATA[<h2>Git配置</h2>

<p><strong>/etc/gitconfig</strong>：系统中对所有用户都普遍适用的配置。若使用git config时用 &#8211;system 选项，读写的就是这个文件。 <br/>
<strong>~/.gitconfig</strong>：用户目录下的配置文件只适用于该用户。若使用git config时用 &#8211;global选项，读写的就是这个文件。 <br/>
<strong>.git/config</strong>：这里的配置仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖 /etc/giconfig 中的同名变量。</p>

<h2>文件状态</h2>

<p><strong>untracked</strong>：未加入版本控制管理的文件。<br/>
<strong>tracked</strong>：已纳入版本控制管理的文件。<br/>
<strong>unmodified</strong>：未做过修改，并且已经在版本控制管理中的文件。<br/>
<strong>modified</strong>：做过修改的受版本控制管理的文件。<br/>
<strong>staged</strong>：已放入暂存区的文件。untracked或者modified的文件，执行过git add后，就进入了暂存区。</p>

<!-- more -->


<h2>.gitignore格式规范</h2>

<ol>
<li>所有空行或者以注释符号 # 开头的行都会被Git忽略。</li>
<li>可以使用标准的glob模式匹配。glob模式是指shell所使用的简化了的正则表达式。星号（*）匹配零个或多个任意字符；[abc]匹配任何一个列在方括号中的字符；问号（?）只匹配一个任意字符；[a-z]匹配所有在这两个字符范围内的字符。</li>
<li>匹配模式最后跟反斜杠（/）说明要忽略的是目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</li>
</ol>


<h2>图形化工具</h2>

<p>在项目工作目录中输入 <strong>gitk</strong> 命令后，图形化工具就会启动。</p>

<h2>HEAD</h2>

<p>HEAD是一个指向正在工作中的本地分支的指针。</p>

<h2>Git命令</h2>

<p><strong>git init</strong><br/>
将当前目录加入Git管理。</p>

<p><strong>git clone [url]</strong><br/>
克隆仓库。</p>

<p><strong>git clone [url] [name]</strong><br/>
自定义克隆仓库的名称。<br/>
<em>&#8211;bare</em> 把现有仓库导出未裸仓库，name以 .git 结尾。</p>

<p><strong>git status</strong><br/>
查看当前文件状态。</p>

<p><strong>git add [file/dir]</strong><br/>
跟踪新文件或目录。如果是目录的话，将递归跟踪该目录下的所有文件。该操作会将目标文件放入暂存区，同时untracked的文件标记为需要track，还能用于合并时把有冲突的文件标记为已解决状态。在执行了git add操作后，又对文件做出了修改，需要再次执行git add操作，否则执行提交操作时，只会将修改前的版本提交到仓库中。</p>

<p><strong>git diff</strong><br/>
查看尚未暂存的文件的变化内容。此命令比较的是工作目录中当前文件和暂存区域快照之间的差异。<br/>
<em>&#8211;cached</em> / <em>&#8211;staged</em> 查看已经暂存起来的文件和上次提交时的快照之间的差异。</p>

<p><strong>git commit</strong><br/>
提交暂存区域的更新。没有提交到暂存区的文件，提交时不会包含。这种无参数的提交命令会启动文本编辑器以便输入本次提交的说明。 <br/>
<em>-m <comments></em> 可以直接执行提交操作。<br/>
<em>-a</em> Git会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过git add步骤。<br/>
<em>&#8211;amend</em> 撤销刚才的提交操作，使用当前的暂存区域快照重新提交。</p>

<p><strong>git reset HEAD [file]</strong><br/>
取消已经暂存的文件。</p>

<p><strong>git checkout &#8211; [file]</strong><br/>
取消对未放入暂存区的文件的修改。</p>

<p><strong>git rm [file/dir]</strong><br/>
从已跟踪文件清单中移除文件，并从工作目录中删除指定的文件，才不会出现在未跟踪的文件清单中。<br/>
<em>-f</em>  强制删除已经放到暂存区域并且做过修改的文件。<br/>
<em>&#8211;cached</em>  将文件从Git仓库中删除（即移除跟踪），但仍然保留在当前工作目录中。<br/>
在路径中加上 \* 会递归删除当前目录及子目录中所有匹配的文件。</p>

<p><strong>git mv [from_file] [to_file]</strong><br/>
重命名操作。<br/>
该命令相当于运行了下面三条命令：</p>

<pre><code>$ mv [from_file] [to_file]
$ git rm [from_file]
$ git add [to_file]
</code></pre>

<p><strong>git remote</strong><br/>
查看当前的远程库。在克隆完某个项目后，至少可以看到一个名为origin的远程库。<br/>
<em>-v</em> 显示对应的克隆地址。</p>

<p><strong>git remote add [shortname] [url]</strong><br/>
提交一个新的远程仓库。</p>

<p><strong>git fetch [remote-name]</strong><br/>
从远程仓库抓取数据到本地。fetch命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支。</p>

<p><strong>git pull</strong><br/>
如果设置了某个分支用于跟踪某个远端仓库的分支，可以使用git pull命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中的当前分支。git clone命令本质上就是自动创建了本地的master分支用于跟踪远程仓库中的master分支。</p>

<p><strong>git push [remote-name] [branch-name]</strong><br/>
将本地仓库中的数据推送到远程仓库。</p>

<p><strong>git push [remote-name] :[branch-name]</strong><br/>
删除远程分支。</p>

<p><strong>git remote show [remote-name]</strong><br/>
查看远程仓库的详细信息。</p>

<p><strong>git remote rename [origin-shortname] [shortname]</strong><br/>
修改远程仓库在本地的简短名称。</p>

<p><strong>git remote rm [shortname]</strong><br/>
删除对应的远端仓库。</p>

<p><strong>git tag</strong><br/>
列出现有的标签。<br/>
<em>-l <pattern></em> 用特定的搜索模式列出符合提交的标签。 <br/>
<em>&lt;tagname></em> 创建一个轻量级标签。轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。<br/>
<em>-a <tagname></em> 创建一个含附注类型的标签。附注标签实际上是存储在仓库中的一个独立对象，它有自身的校验和信息。 <br/>
<em>-m</em> 指定对应的标签说明。</p>

<p><strong>git show [tagname]</strong><br/>
查看相应标签的版本信息。</p>

<p><strong>git push origin [tagname]</strong><br/>
默认情况下，git push并不会把标签传送到远端服务器上，只用通过显示命令才能分享标签到远端仓库。<br/>
<em>&#8211;tags</em> 一次推送所有本地新增的标签上去。</p>

<p><strong>git branch [branchname]</strong><br/>
创建分支。如果没指定branchname，则列出所有的分支，并标明当前所在分支。<br/>
<em>-b</em> 创建分支并切换到该分支。<br/>
<em>-d</em> 删除分支。如果该分支还没并入当前分支，则不允许删除。<br/>
<em>-D</em> 强制删除分支。<br/>
<em>-v</em> 查看各个分支最后一个提交对象的信息。<br/>
<em>&#8211;merge</em> 查看哪些分支已被并入当前分支。 <br/>
<em>&#8211;no-merged</em> 查看哪些分支尚未并入当前分支。</p>

<p><strong>git checkout [branchname]</strong><br/>
切换到其它分支，此时HEAD指向新的分支。</p>

<p><strong>git merge [branchname]</strong><br/>
合并分支到当前分支。<br/>
<em>&#8211;squash</em> 将目标分支上的所有更改全拿来应用到当前分支。<br/>
<em>&#8211;no-commit</em> 告诉Git此时无需自动生成和记录（合并）提交。</p>

<p><strong>git rebase [branchname]</strong><br/>
rebase分支内容到当前分支。<br/>
<em>&#8211;onto</em> 指定新的基底分支。</p>

<p><strong>git log</strong><br/>
查看提交历史。默认会按提交时间列出所有的更新，最近的更新排在最上面。</p>

<pre><code>-[n] 仅显示最近的n条提交。
--since, --after 仅显示指定时间之后的提交。
--until, --before 仅显示指定时间之前的提交。
--author 仅显示指定作者相关的提交。
--committer 仅显示指定提交者相关的提交。
--grep 搜索提交说明中的关键字。如果要得到同时满足这两个选项搜索条件的提交，就必须用 --all-match 选项，否则，满足任意一个条件的提交都会被匹配出来。
-- [path] 显示指定的文件或目录的历史提交。
-p 展开显示每次提交的内容差异。
--stat 显示每次更新的文件修改统计信息。
--shortstat 只显示 --stat 中最后的行数修改提交移除统计。
--name-only 仅在提交信息后显示已修改的文件清单。
--abbrev-commit 仅显示SHA-1的前几个字符，而非所有的40个字符。
--relative-date 使用较短的相对时间显示（比如 “2 weeks ago”）。
--graph 显示ASCII图形表示的分支合并历史。
--pretty 使用其它格式显示历史提交信息。可用的选项包括oneline，short，full，fuller和format（后跟指定格式）。用oneline或format时结合--graph选项，可以看到开头多出一些ASCII字符串表示的简单图形，形象的展示了每个提交所在的分支及其分化衍合情况。oneline将每个提交放在一行显示，这在提交数很大时非常有用。format可以定制要显示的记录格式，这样的输出便于后期提取分析，如：$ git log --pretty=format:"%h - %ar : %s"
</code></pre>

<p>常用的占位符如下：</p>

<pre><code>%H 提交对象（commit）的完整哈希字串
%h 提交对象的简单哈希字串
%T 树对象（tree）的完整哈希字串
%t 树对象的简短哈希字串
%P 父对象（parent）的完整哈希字串
%p 父对象的简短哈希字串
%an 作者（author）的名字
%ae 作者的电子邮件地址
%ad 作者修订日期（可以用 -date 选项定制格式）
%ar 作者修订日期，按多久以前的方式显示
%cn 提交者（committer）的名字
%ce 提交者的电子邮件地址
%cd 提交日期
%cr 提交日期，按多久以前的方式显示
%s 提交说明
</code></pre>

<h2>Tips</h2>

<h3>自动补全</h3>

<p>如果使用的是Bash shell，下载Git的源代码，将<em>contrib/completion/git-completion.bash</em>复制到用户主目录中 <em>cp git-completion.bash ~/.git-completion.bash</em>，并把下面一行内容添加到你的.bashrc文件中：</p>

<pre><code>source ~/.git-completion.bash
</code></pre>

<p>也可以为系统上所有用户都设置默认使用此脚本。Mac上将此脚本复制到<em>/opt/local/etc/bash_completion.d</em>目录中，Linux上则复制到<em>/etc/bash_completion.d</em>目录中。这两处目录中的脚本，都会在Bash启动时自动加载。</p>

<h3>Git命令别名</h3>

<p>可以用git config为命令设置别名，如：</p>

<pre><code>git config --global alias.ci commit
</code></pre>

<h2>Resources</h2>

<p>Pro Git中文版：<a href="http://git-scm.com/book/zh">http://git-scm.com/book/zh</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring NamedParameterJdbcTemplate的内存泄漏问题]]></title>
    <link href="http://askcuix.github.io/blog/2013/05/06/the-memory-leak-problem-of-spring-namedparameterjdbctemplate/"/>
    <updated>2013-05-06T22:36:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2013/05/06/the-memory-leak-problem-of-spring-namedparameterjdbctemplate</id>
    <content type="html"><![CDATA[<p>我们的项目是使用Spring JDBC来操作DB的，通常是直接使用SimpleJdbcTemplate，一直以来也没发现什么问题。今天在做performance test的时候，发现内存增长很快，甚至出现了out of memory。把heap dump拉下来查看后，发现是这次新加的一个service出现了问题，但根源是因为NamedParameterJdbcTemplate中的HashMap导致的。</p>

<p>这里要先说明使用的Spring的版本是2.5.6，在3.0.3中已修复该问题。</p>

<!-- more -->


<p>查看调用的trace是service->SimpleJdbcTemplate->NamedParameterJdbcTemplate。一直没有仔细看过SimpleJdbcTemplate的源码，其实它基本都是通过调用NamedParameterJdbcTemplate来完成操作的。SimpleJdbcTemplate的初始化，其实就是初始化NamedParameterJdbcTemplate。</p>

<figure class='code'><figcaption><span>SimpleJdbcTemplate.java</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>   <span class="kd">public</span> <span class="nf">SimpleJdbcTemplate</span><span class="o">(</span><span class="n">DataSource</span> <span class="n">dataSource</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">namedParameterJdbcOperations</span> <span class="o">=</span> <span class="k">new</span> <span class="n">NamedParameterJdbcTemplate</span><span class="o">(</span><span class="n">dataSource</span><span class="o">);</span>
</span><span class='line'>   <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>   <span class="kd">public</span> <span class="nf">SimpleJdbcTemplate</span><span class="o">(</span><span class="n">JdbcOperations</span> <span class="n">classicJdbcTemplate</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">namedParameterJdbcOperations</span> <span class="o">=</span> <span class="k">new</span> <span class="n">NamedParameterJdbcTemplate</span><span class="o">(</span><span class="n">classicJdbcTemplate</span><span class="o">);</span>
</span><span class='line'>   <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>   <span class="kd">public</span> <span class="nf">SimpleJdbcTemplate</span><span class="o">(</span><span class="n">NamedParameterJdbcOperations</span> <span class="n">namedParameterJdbcTemplate</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">namedParameterJdbcOperations</span> <span class="o">=</span> <span class="n">namedParameterJdbcTemplate</span><span class="o">;</span>
</span><span class='line'>   <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>NamedParameterJdbcTemplate的作用是方便使用命名式的参数，以代替使用SQL中的‘?’。NamedParameterJdbcTemplate会将每次解析过后的SQL放在一个HashMap中，以起到cache的作用，而问题就出现这个Map上。</p>

<figure class='code'><figcaption><span>NamedParameterJdbcTemplate.java</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>   <span class="kd">private</span> <span class="kd">final</span> <span class="n">Map</span> <span class="n">parsedSqlCache</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>   <span class="kd">protected</span> <span class="n">ParsedSql</span> <span class="nf">getParsedSql</span><span class="o">(</span><span class="n">String</span> <span class="n">sql</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">parsedSqlCache</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">ParsedSql</span> <span class="n">parsedSql</span> <span class="o">=</span> <span class="o">(</span><span class="n">ParsedSql</span><span class="o">)</span> <span class="k">this</span><span class="o">.</span><span class="na">parsedSqlCache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">sql</span><span class="o">);</span>
</span><span class='line'>          <span class="k">if</span> <span class="o">(</span><span class="n">parsedSql</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>              <span class="n">parsedSql</span> <span class="o">=</span> <span class="n">NamedParameterUtils</span><span class="o">.</span><span class="na">parseSqlStatement</span><span class="o">(</span><span class="n">sql</span><span class="o">);</span>
</span><span class='line'>              <span class="k">this</span><span class="o">.</span><span class="na">parsedSqlCache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">sql</span><span class="o">,</span> <span class="n">parsedSql</span><span class="o">);</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>          <span class="k">return</span> <span class="n">parsedSql</span><span class="o">;</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>从上面的代码可以看到，NamedParameterJdbcTemplate不断的将解析过的SQL放入parsedSqlCache中，但并没有任何限制，而我们的service会根据不同的条件产生不同的SQL（条件参数比较多），同时这个SimpleJdbcTemplate也是share的，因此出现了out of memory的问题，当然，测试server的配置比较差也是其中一个原因。</p>

<p>这个问题可以参见<a href="https://jira.springsource.org/browse/SPR-7237">Spring Bug 7237</a>，该问题已在3.0.3中修复。</p>

<p>由于该阶段已不可能升级Spring的版本，潜在的风险太大，因此可自己实现一个NamedParameterJdbcTemplate，去override掉getParsedSql方法，可取消cache的作用，或参考Spring 3中的实现。</p>

<figure class='code'><figcaption><span>NamedParameterJdbcTemplate.java</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>   <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">DEFAULT_CACHE_LIMIT</span> <span class="o">=</span> <span class="mi">256</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>   <span class="kd">private</span> <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">cacheLimit</span> <span class="o">=</span> <span class="n">DEFAULT_CACHE_LIMIT</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>   <span class="kd">private</span> <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">ParsedSql</span><span class="o">&gt;</span> <span class="n">parsedSqlCache</span> <span class="o">=</span>
</span><span class='line'>          <span class="k">new</span> <span class="n">LinkedHashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">ParsedSql</span><span class="o">&gt;(</span><span class="n">DEFAULT_CACHE_LIMIT</span><span class="o">,</span> <span class="mf">0.75f</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">removeEldestEntry</span><span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">ParsedSql</span><span class="o">&gt;</span> <span class="n">eldest</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">return</span> <span class="nf">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">getCacheLimit</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="o">};</span>
</span><span class='line'>
</span><span class='line'>   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setCacheLimit</span><span class="o">(</span><span class="kt">int</span> <span class="n">cacheLimit</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">cacheLimit</span> <span class="o">=</span> <span class="n">cacheLimit</span><span class="o">;</span>
</span><span class='line'>   <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>   <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getCacheLimit</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">cacheLimit</span><span class="o">;</span>
</span><span class='line'>   <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>   <span class="kd">protected</span> <span class="n">ParsedSql</span> <span class="nf">getParsedSql</span><span class="o">(</span><span class="n">String</span> <span class="n">sql</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">getCacheLimit</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">return</span> <span class="n">NamedParameterUtils</span><span class="o">.</span><span class="na">parseSqlStatement</span><span class="o">(</span><span class="n">sql</span><span class="o">);</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">parsedSqlCache</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">ParsedSql</span> <span class="n">parsedSql</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">parsedSqlCache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">sql</span><span class="o">);</span>
</span><span class='line'>          <span class="k">if</span> <span class="o">(</span><span class="n">parsedSql</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>              <span class="n">parsedSql</span> <span class="o">=</span> <span class="n">NamedParameterUtils</span><span class="o">.</span><span class="na">parseSqlStatement</span><span class="o">(</span><span class="n">sql</span><span class="o">);</span>
</span><span class='line'>              <span class="k">this</span><span class="o">.</span><span class="na">parsedSqlCache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">sql</span><span class="o">,</span> <span class="n">parsedSql</span><span class="o">);</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>          <span class="k">return</span> <span class="n">parsedSql</span><span class="o">;</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>   <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后更改一下SimpleJdbcTemplate的实例化方式，先实例化一个改写过的NamedParameterJdbcTemplate，然后作为SimpleJdbcTemplate构造函数的参数来进行实例化。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[垃圾收集器及内存分配]]></title>
    <link href="http://askcuix.github.io/blog/2013/04/16/garbage-collection-and-memory-allocation/"/>
    <updated>2013-04-16T23:54:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2013/04/16/garbage-collection-and-memory-allocation</id>
    <content type="html"><![CDATA[<p>程序计数器、虚拟机栈和本地方法栈的内存分配大体在编译器就可以确定，并且这些区域和线程有着相同的生命周期，在方法或线程结束时，内存也就回收了。而Java堆和方法区的内存分配和回收都是动态的，只有在程序运行期间才知道会创建哪些对象，因此是垃圾收集器所关注的内存区域。</p>

<h2>对象标记算法</h2>

<p>Java堆中存放着所有对象实例，垃圾收集器在进行回收前，需要根据算法来确定哪些对象已不再被使用，可进行回收。</p>

<h3>引用计数算法</h3>

<p>该算法是给对象添加一个引用计数器，每当有引用它时，计数器就加1；当引用失效时，计数器就减1；当计数器为0时就不能被使用了。这种算法的判定效率很高，但是很难解决Java对象之间的循环引用问题，因此未被Java语言采用。</p>

<h3>根搜索算法</h3>

<p>通过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象当GC Roots没有任何引用链相连时，则此对象就不能被使用了。</p>

<p>可作为GC Roots的对象包括：
- 虚拟机栈中的局部变量表所引用的对象。 <br/>
- 方法区中的类静态属性引用的对象。  <br/>
- 方法区中的常量引用的对象。 <br/>
- 本地方法栈中JNI所引用的对象。</p>

<!-- more -->


<h2>Java引用</h2>

<p><strong>强引用</strong>：在代码中普遍存在的，比如“Object obj = new Object()”，只要强引用还存在，垃圾收集器则永远都不会回收引用的对象。</p>

<p><strong>软引用</strong>：一些还有用，但并非必须的对象。对于软引用关联的对象，在发生内存溢出之前，会将这些对象纳入回收范围并进行回收。</p>

<p><strong>弱引用</strong>：非必须对象，比软引用更弱一些，弱引用所关联的对象只能生存到下一次垃圾回收之前。当垃圾收集器工作时，无论当前内存是否够用，都会回收弱引用所关联的对象。</p>

<p><strong>虚引用</strong>：最弱的一种引用关系，一个对象是否被虚引用所关联，完全不会对其生存时间产生影响，也不能通过虚引用来取得对象实例，关联的唯一目的是在这个对象被垃圾回收器回收时收到一个系统通知。</p>

<h2>垃圾收集算法</h2>

<h3>标记-清除算法</h3>

<p>首先标记出所有需要回收的对象，之后统一回收所有被标记的对象。该算法效率较低，并会产生大量不连续的内存碎片。</p>

<h3>复制算法</h3>

<p>将新生代内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor，回收时将Eden和使用的Survivor中存活的对象一次性拷贝到另一块Survivor空间，然后清理Eden和之前使用的Survivor空间。</p>

<p>HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，因此新生代中可用内存为整个新生代容量的90%。当Survivor空间不够用时，将依赖老年代内存进行分配担保。</p>

<h3>标记-整理算法</h3>

<p>与标记-清除算法类似，但最后步骤不是直接对可回收对象进行清除，而是将所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>

<h3>分代收集算法</h3>

<p>将Java堆分为新生代和老年代，对每个年代采用合适的收集算法。</p>

<h2>垃圾收集器</h2>

<h3>Serial收集器</h3>

<p>单线程新生代收集器，在进行垃圾收集时，必须暂停所有的工作线程，导致停顿。与其它收集器的单线程相比简单高效，对于单CPU的环境没有线程交互的开销，收集效率较高。</p>

<h3>ParNew收集器</h3>

<p>新生代收集器，Serial收集器的多线程版本，是目前除Serial收集器外，唯一能够和CMS收集器配合工作的。默认开启的收集线程数与CPU的数量相同，可通过-XX:ParallelGCThreads来限制线程数。</p>

<p>ParNew收集器是使用-XX:+UseConcMarkSweepGC后的默认新生代收集器，也可以使用-XX:+UseParNewGC来强制指定。</p>

<h3>Parallel Scavenge收集器</h3>

<p>新生代收集器，以达到可控制的吞吐量为目标。可通过-XX:MaxGCPauseMillis来控制最大垃圾收集停顿时间，-XX:GCTimeRatio来控制吞吐量大小，-XX:+UseAdaptiveSizePolicy来实现自适应调节策略。</p>

<h3>Serial Old收集器</h3>

<p>Serial收集器的老年代版本。可在JDK1.5及之前版本中配合Parallel Scavenge收集器使用，也可在CMS收集器发生Concurrent Mode Failure时使用。</p>

<h3>Parallel Old收集器</h3>

<p>Parallel Scavenge收集器的老年代版本。使用多线程和“标记-整理”算法，在JDK1.6中开始提供。和Parallel Scavenge收集器配合使用非常适合注重吞吐量和CPU资源有限的场景。</p>

<h3>CMS（Concurrent Mark Sweep）收集器</h3>

<p>老年代收集器，以获取最短回收停顿时间为目标。默认启动的收集线程数是 (CPU数量+3) / 4。在并发阶段因占用一部分线程而导致应用程序变慢，总吞吐量下降。CMS收集器默认在老年代使用68%的空间后被激活，可通过调高-XX:CMSInitiatingOccupancyFraction来提高触发百分比，以降低内存回收次数。</p>

<p>若CMS运行期间预留的内存无法满足程序需要，就会出现“Concurrent Mode Failure”失败，虚拟机会临时启用Serial Old收集器来重新进行老年代的垃圾收集。</p>

<p>由于使用“标记-清除”算法会产生大量空间碎片，从而导致Full GC，可通过-XX:+UseCMSCompactAtFullCollection在Full GC后进行碎片整理。</p>

<h3>G1收集器</h3>

<p>使用“标记-整理”算法避免产生空间碎片，可以精确控制垃圾收集的时间。通过将整个Java堆划分为多个大小固定的独立区域，每次根据允许的收集时间，优先回收垃圾最多的区域，以此来保证在有限的时间内获取最高的收集效率。</p>

<h2>内存分配</h2>

<p>对象通常在新生代Eden区中分配，当Eden区没有足够空间时，将触发一次Minor GC。</p>

<p>需要大量连续内存的大对象将直接在老年代中分配，以避免新生代中发生大量的内存拷贝，可通过-XX:PretenureSizeThreshold来设置。</p>

<p>虚拟机为每个对象定义了年龄计数器，并通过Minor GC的次数来增加年龄，当达到-XX:MaxTenuringThreshold设置的阀值时，会将对象移入老年代。</p>

<p>若新生代中Survivor空间中相同年龄的对象大小总和大于Survivor空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代。</p>

<p><strong>新生代GC（Minor GC）</strong>：新生代的垃圾回收操作，Java对象的生命周期通常较短，因此Minor GC非常频繁。 <br/>
<strong>老年代GC（Major GC / Full GC）</strong>：老年代的垃圾回收操作，发生Full GC通常也会发生至少一次的Minor GC，GC的速度很慢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Korn Shell Script]]></title>
    <link href="http://askcuix.github.io/blog/2013/04/14/korn-shell-script/"/>
    <updated>2013-04-14T23:45:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2013/04/14/korn-shell-script</id>
    <content type="html"><![CDATA[<h2>基本语法</h2>

<p>&#8221;;&#8221;作为语句的结束，因此可以将多个command写在一行。</p>

<pre><code> print -n "Name: "; read name; print ""
</code></pre>

<p>&#8220;&#92;&#8221; 可将第二行command与第一行连接起来，若command太长，可通过这种方式写在多行上。</p>

<pre><code> grep filename | sort -u | awk '{print $4}' | \
 uniq -c &gt;&gt; /longpath/file
</code></pre>

<h2>Variables</h2>

<p><strong>Arrays</strong></p>

<p><strong>arrname[1]=4</strong>  To fill in <br/>
<strong>print ${arraname[1]}</strong>  To print out <br/>
<strong>${arrname[*]}</strong>  Get all elements <br/>
<strong>${#arrname[*]}</strong>  Get the number of elements</p>

<!-- more -->


<h2>Branching</h2>

<p><strong>if</strong></p>

<pre><code> if [[ $value -eq 7 ]]   

 then   
    print "$value is 7"   
 fi
</code></pre>

<p><strong>if … else</strong></p>

<pre><code> if [[ $name = "John" ]]
 then
    print "Your welcome, ${name}."
 else
    print "Good bye, ${name}!"
 fi
</code></pre>

<p><strong>if &#8230; elif &#8230; else</strong></p>

<pre><code> if [[ $name = "John" ]]
 then
    print "Your welcome, ${name}."
 elif [[ $name = "Hanna" ]]
 then
    print "Hello, ${name}, who are you?"
 else
    print "Good bye, ${name}!"
 fi
</code></pre>

<p><strong>case</strong></p>

<pre><code> case $var in
   john|fred)  print $invitation;;
   martin)  print $declination;;
   *)  print "Wrong name…";;
 esac
</code></pre>

<h2>Looping</h2>

<p><strong>while</strong></p>

<pre><code> while [[ $count -gt 0 ]];do
    print "\$count is $count"
    (( count -= 1 ))
 done
</code></pre>

<p><strong>until</strong></p>

<pre><code> until [[ $answer = "yes" ]];do
    print -n "Please enter \"yes\": "
    read answer
    print ""
 done
</code></pre>

<p><strong>for</strong></p>

<pre><code> for foo in $(ls);do
    if [[ -d $foo ]];then
       print "$foo is a directory"
    else
       print "$foo is not a directory"
    fi
 done
</code></pre>

<p><strong>continue</strong></p>

<pre><code> while read line
 do
   if [[ $line = *.gz ]];then
      continue
   else
      print $line
   fi
 done
</code></pre>

<p><strong>break</strong></p>

<pre><code> while read line;do
     if [[ $line = *!(.c) ]];then
        break
     else
        print $line
     fi
 done
</code></pre>

<h2>Comparisons</h2>

<p><strong>字符比较</strong>：&#8221;=&#8221;用于相等，&#8221;!=&#8221;用于不等。 <br/>
<strong>数字比较</strong>：&#8221;-eq&#8221;用于相等，&#8221;-ne&#8221;用于不等，&#8221;-gt&#8221;用于大于，&#8221;-lt&#8221;用于小于。 <br/>
<strong>与或比较</strong>：&#8221;&amp;&amp;&#8221;表示与，&#8221;||&#8221;表示或。</p>

<h2>变量操作</h2>

<p><strong>${name##*/}</strong>：用于从包含路径的变量中取出文件名。  <br/>
<strong>${name%/*}</strong>：用于从包含路径的变量中取出路径。  <br/>
<strong>dirname</strong>：用于获取文件的路径，不包含文件名。如：dirname $0 <br/>
<strong>${foo:-4}</strong>：如果foo不存在，则返回4，但foo仍然没有值。  <br/>
<strong>${foo:=4}</strong>：如果foo不存在，则附值4给foo。  <br/>
<strong>${foo:+1}</strong>：如果foo有值，则返回1，但foo的值不改变。  <br/>
<strong>${foo:?&#8221;foo not set!&#8221;}</strong>：如果foo不存在，则退出程序并显示&#8221;foo not set!&#8221;。 <br/>
<strong>${foo:startOffset}</strong>：从startOffset处开始截取字符串foo到末尾。 <br/>
<strong>${foo:startOffset:endOffset}</strong>：截取字符串foo从startOffset到endOffset。</p>

<h2>特殊变量</h2>

<p><strong>$#</strong>：命令行参数的个数。 <br/>
<strong>$1, &#8230;.$n</strong>：单个命令行参数。 <br/>
<strong>$*</strong>：所有的命令行参数。  <br/>
<strong>$0</strong>：当前script的名字，如果是从另外一个目录执行的，还将包含路径信息。  <br/>
<strong>$?</strong>：上个command执行结果的状态。 <br/>
<strong>$$</strong>：当前script的pid。  <br/>
<strong>$!</strong>：最后一个后台执行的程序的pid。 <br/>
<strong>shift</strong>：删除第一个命令行参数。</p>

<h2>数据重定向</h2>

<p><strong>command > file</strong>：将输出写到新文件或覆盖已存在的文件。 <br/>
<strong>command >> file</strong>：将输出添加在已存在文件中。 <br/>
<strong>command 2> file</strong>：将错误输出重定向到文件。 <br/>
<strong>command 2>/dev/null</strong>：丢弃错误信息。  <br/>
<strong>command 2>&amp;1</strong>：将错误输出重定向到正常输出。  <br/>
<strong>command &lt; file</strong>：从标准输入读取文件。  <br/>
<strong>command &lt; infile > outfile</strong>：组合输入和输出重定向。</p>

<h2>Read Input from User and from Files</h2>

<p><strong>read var</strong>：读取用户输入的变量。如：</p>

<pre><code> print -n "Enter your favorite haircolor: ";read var; print ""。
</code></pre>

<p><strong>按行读取文件的内容到变量</strong>：</p>

<pre><code> { while read myeline;do
      # process $myline
 done } &lt; filename
</code></pre>

<h2>Calculation</h2>

<p>简单的计算可通过 &#8220;let&#8221; 或  (( … ))。如：(( a+=1 )) 或 let a+=1。</p>

<h2>typeset用法</h2>

<p>typeset用于设置变量属性，如大小写、宽度、左右对齐等都可以用typeset来控制, 当用typeset改变一个变量的属性时,这种改变是永久的。</p>

<p>选项：</p>

<p><strong>-u</strong>：将一个变量的字符变成大写。  <br/>
<strong>-l</strong>：将一个变量的字符变成小写。  <br/>
<strong>-L<num></strong>：将变量变成一个左对齐的num长度的字符串，有些像字符串截取。 <br/>
<strong>-R<num></strong>：将变量变成一个右对齐的num长度的字符串。 <br/>
<strong>-Z<num></strong>：将变量变成一个空格填充，占num个字符位的字符串。 <br/>
<strong>-i</strong>：强制变量为一个整数。 <br/>
<strong>-r</strong>：设置一个只读变量。</p>

<p>文件状态测试</p>

<p><strong>-b filename</strong>：当filename 存在并且是块文件时返回真。 <br/>
<strong>-c filename</strong>：当filename 存在并且是字符文件时返回真。 <br/>
<strong>-d pathname</strong>：当pathname 存在并且是一个目录时返回真。 <br/>
<strong>-e pathname</strong>：当由pathname 指定的文件或目录存在时返回真。 <br/>
<strong>-f filename</strong>：当filename 存在并且是正规文件时返回真。 <br/>
<strong>-h filename</strong>：当filename 存在并且是符号链接文件时返回真。 <br/>
<strong>-r pathname</strong>：当由pathname 指定的文件或目录存在并且可读时返回真。 <br/>
<strong>-s filename</strong>：当filename 存在并且文件大小大于0 时返回真。 <br/>
<strong>-w pathname</strong>：当由pathname 指定的文件或目录存在并且可写时返回真。 <br/>
<strong>-x pathname</strong>：当由pathname 指定的文件或目录存在并且可执行时返回真。 <br/>
<strong>-O pathname</strong>：当由pathname 存在并且被当前进程的有效用户id 的用户拥有时返回真。 <br/>
<strong>-G pathname</strong>：当由pathname 存在并且属于当前进程的有效用户id 的用户的用户组时返回真。 <br/>
<strong>file1 -nt file2</strong>：file1 比file2 新时返回真。 <br/>
<strong>file1 -ot file2</strong>：file1 比file2 旧时返回真。</p>

<h2>字符串测试</h2>

<p><strong>-z string</strong>：字符串string 为空串(长度为0)时返回真。 <br/>
<strong>-n string</strong>：字符串string 为非空串时返回真。</p>

<h2>Resources</h2>

<p>Korn Shell Programming：<a href="http://www.bo.infn.it/alice/alice-doc/mll-doc/impgde/node15.html">http://www.bo.infn.it/alice/alice-doc/mll-doc/impgde/node15.html</a> <br/>
Learning the Korn Shell: <a href="http://docstore.mik.ua/orelly/unix/ksh/">http://docstore.mik.ua/orelly/unix/ksh/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The foundation of spring batch]]></title>
    <link href="http://askcuix.github.io/blog/2013/04/01/the-foundation-of-spring-batch/"/>
    <updated>2013-04-01T22:46:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2013/04/01/the-foundation-of-spring-batch</id>
    <content type="html"><![CDATA[<p>Spring Batch是埃森哲贡献给Spring的一个开源项目，现在由双方共同维护。通过Spring Batch可以构建出轻量级的大数据量并⾏处理应⽤,⽀持事务、并发、流程、监控、纵向和横向扩展,提供统一的接口管理。Spring Batch并不包含scheduler，它只是一个通用的batch处理框架，你可以通过QuartZ，Control-M等scheduler去调用。</p>

<p>Spring Batch能够处理大批量数据的导入、导出和业务逻辑计算，执行过程无需人工干预。我们的系统是一个金融产品信息的数据中心，需要从不同的系统读取产品信息，也需要将这些信息提供给其它的系统，这种data loading就是Spring Batch的一种应用场景。</p>

<!-- more -->


<p><img src="http://askcuix.github.io/images/blog/spring_batch_common_process.png" alt="Spring Batch Common Process" /></p>

<p>上图就是Spring Batch的常用方式，从DB或是不同类型的文件中读取数据，经过转换后再写入DB或者文件。</p>

<p><img src="http://askcuix.github.io/images/blog/spring_batch_domain.png" alt="Spring Batch Domain" /></p>

<p>上图是一个Job执行的结构图，下面是对这些domain对象的简单描述，只是学习时随笔记下来的，不够详细，可以查看Spring Batch文档中的描述。</p>

<h2>Job</h2>

<p>Job是对一个batch处理流程的定义，可以简单理解为Spring中的一个Job配置，一般都包括reader和writer。</p>

<h2>JobInstance</h2>

<p>JobInstance是Job运行时产生的实例，如果这个Job是按天执行的，则每天都会创建一个JobInstance；当Job执行失败时，restart这个Job将会重用JobInstance，以便于从执行失败的地方开始重新执行。</p>

<h2>JobParameter</h2>

<p>JobParameter用于标识一个JobInstance，可以将它理解为JobInstance的ID。</p>

<h2>JobListener</h2>

<p>JobListener可以监听JobInstance生命周期中的两个事件：</p>

<p><strong>beforeJob</strong> - 在Job执行前被调用。</p>

<p><strong>afterJob</strong> - 不论Job执行成功或失败都会被调用，Job的status可以从JobExecution中获取。</p>

<h2>Parent Job</h2>

<p>对于相似的Job，可以取出相同的部分定义成一个parent Job，只需要在Job定义时添加<em>abstract=&#8221;true&#8221;</em>，然后在sub Job中通过<em>parent</em>属性来指定parent Job。</p>

<h2>JobRepository</h2>

<p>MapJobRepository通常用于测试环境或是standalone的batch。它不够稳定；不允许在不同JVM实例之间执行restart；也不能保证有相同JobParameter的两个JobInstance同时运行；它不适合在多线程Job或本地的partition step中使用。但是它仍然需要配置transaction manager，因为在Job的实现中会涉及到rollback的问题，所以可以用ResourcelessTransactionManager来代替。</p>

<h2>JobLauncher</h2>

<p>JobLauncher使用spring的taskExecutor来实现异步处理，只需要在配置中指定taskExecutor属性。如果batch是通过http request的方式触发的，那应当使用异步的方式来处理Job以避免长时间的占用链接。</p>

<h2>JobOperator</h2>

<p>JobOperator的stop()不会立刻停止一个Job，如果当前流程处理的控制权在framework，则会将StepExecution的status设置为STOPPED并保存，然后按正常的处理流程结束Job。</p>

<p>如果不希望一个restartable的Job在执行失败后restart，可以将status设置为ABORTED。</p>

<h2>JobParametersIncrementer</h2>

<p>JobParametersIncrementer可强制创建一个新的jobInstance，以避免在使用相同JobParameter时不可以再次执行Job。这只是个接口，需要自己去实现getNext()，然后在Job中定义incremented属性来引用它。</p>

<h2>Step</h2>

<p><strong>start-limit</strong>： 用于step的restart，用来控制一个start的次数。默认是Integer.MAX_VALUE。<br/>
<strong>allow-start-if-complete</strong>： 强制执行step，不管之前执行成功或失败。</p>

<h3>Skip</h3>

<p>通过指定exception来决定是否skip有问题的数据，可以结合include和exclude来定义exception列表。</p>

<p><strong>skip-limit</strong>：用来控制允许skip的数据的最大数量，在step execution中分别保存有针对read，process和write中skip的数量。</p>

<h3>Retry</h3>

<p>通过指定exception来指定是否允许重试当前有问题的错误数据，对于一些通过重试可以解决问题的数据是非常有用的，比如更新当前数据到DB时，该条数据被其它进程lock了，则在重试时可能就可以正常更新了。</p>

<p><strong>retry-limit</strong>：用来控制每个item允许重试的次数。</p>

<h3>Rollback</h3>

<p>通过指定exception来忽略rollback操作。对于Skip和Retry，如果Exception是由ItemWriter抛出的，则step中被当前transaction控制的数据会被rollback，因此要配合使用no-rollback-exception-classes来决定是否应该执行rollback。</p>

<p>Step通常会缓存Reader读入的数据，如果发生了rollback则不需要重新读入数据，但是对于一些基于transaction资源的Reader，比如从JMS queue中读取数据的Reader，JMS message也会执行rollback，则需要通过is-reader-transactional-queue来标识不需要缓存读入数据。</p>

<h2>ItemStream</h2>

<p>在Step执行失败需要restart时，可以通过ItemStream获取存储在execution之间状态信息。如果ItemReader，ItemProcessor或者ItemWriter实现了ItemStream接口，则会自动被注册在Spring Context中；否则需要单独注册streams。对于CompositeItemWriter，如果delegate的ItemWriter实现了ItemStream接口，也需要主动注册。</p>

<h2>StepListener</h2>

<p>和ItemStream一样，如果ItemReader，ItemProcessor或者ItemWriter实现了StepListener接口，则会被自动注册。</p>

<h3>StepExecutionListener</h3>

<p><strong>beforeStep</strong> - 在step执行之前调用。<br/>
<strong>afterStep</strong> - 在step结束时调用，不管执行成功或失败。可以在这里更改ExitStatus。</p>

<h3>ChunkListener</h3>

<p><strong>beforeChunk</strong> - 被调用在transaction开始后，但在ItemReader的read方法执行前。<br/>
<strong>afterChunk</strong> - chunk被commit/rollback后被调用。</p>

<p>ChunkListener也可被用在未使用chunk方式的step中，比如Tasklet， 会在tasklet执行前后被调用。</p>

<h3>ItemReadListener</h3>

<p><strong>beforeRead</strong> - 在read方法执行前被调用。<br/>
<strong>afterRead</strong> - 在read方法执行成功后被调用，并返回读到的item作为参数。<br/>
<strong>onReadError</strong> -  在read方法出现异常时被调用，并提供异常的类型作为参数。</p>

<h3>ItemProcessListener</h3>

<p><strong>beforeProcess</strong> - 在ItemProcessor的process方法执行前被调用。<br/>
<strong>afterProcess</strong> - 在process方法执行成功后被调用。<br/>
<strong>onProcessError</strong> - 在process方法出现异常时被调用，并提供item和异常作为参数。</p>

<h3>ItemWriteListener</h3>

<p><strong>beforeWrite</strong> - 在ItemWriter的write方法执行前被调用。<br/>
<strong>afterWrite</strong> - 在ItemWriter的write方法执行成功后被调用。<br/>
<strong>onWriteError</strong> - 在ItemWriter的write方法出现异常时被调用，并提供chunk data和异常作为参数。</p>

<h3>SkipListener</h3>

<p><strong>onSkipInRead</strong> - 当item在读取阶段skip时被调用。 <br/>
<strong>onSkipInProcess</strong> - 当item在process阶段skip时被调用。<br/>
<strong>onSkipInWrite</strong> -  当item在写入阶段skip时被调用，并且在transaction被commit之前。</p>

<h3>Batch Status vs. Exit Status</h3>

<p>Conditional Flow的配置中的on属性使用Exit Status，通常情况下Batch Status和Exit Status是一样的，但StepExecutionListener可以更改Exit Status。</p>

<h3>Step Scope</h3>

<p>使用Job和Step的属性延迟绑定特性时，必须将Bean的scope设置为step。使用该属性可以通过定义Spring Batch的namespace或者定义StepScope。</p>

<figure class='code'><figcaption><span>applicationContext.xml</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>   <span class="nt">&lt;bean</span> <span class="na">class=</span><span class="s">&quot;org.springframework.batch.core.scope.StepScope&quot;</span> <span class="nt">/&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h2>Resources</h2>

<p>Official site: <a href="http://www.springsource.org/spring-batch">http://www.springsource.org/spring-batch</a></p>

<p>IBM DeveloperWorks - 使用 Spring Batch 构建企业级批处理应用:<br/>
 - <a href="http://www.ibm.com/developerworks/cn/java/j-lo-springbatch1/">http://www.ibm.com/developerworks/cn/java/j-lo-springbatch1/</a><br/>
 - <a href="http://www.ibm.com/developerworks/cn/java/j-lo-springbatch2/">http://www.ibm.com/developerworks/cn/java/j-lo-springbatch2/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Common Format of CSV Files]]></title>
    <link href="http://askcuix.github.io/blog/2013/03/26/common-format-of-csv-files/"/>
    <updated>2013-03-26T23:43:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2013/03/26/common-format-of-csv-files</id>
    <content type="html"><![CDATA[<p>CSV是一种常见的文件格式，常用于不同系统之间的数据交换，对于该文件格式可以简单描述为：一组使用逗号“,”分隔字段，并以换行符作为一行数据结束的数据集合。该文件可以使用Microsoft Excel查看，但是中文字符会显示为乱码。</p>

<p>这个描述就真的只是简单描述，实际上CSV的格式处理没有这么简单。最近在和另外一个系统做集成，我们的系统会提供CSV数据文件给对方系统处理，由于我们系统中个别字段会包括换行符“CRLF”（这是遗留系统，就不用纠结为什么字段中会包含换行符了），也就是说一个字段可能会显示在几行上，但是这个字段是包含在双引号中的，结果对方系统就处理不了了。因为对方系统只是简单的按行处理数据，用逗号解析字段。</p>

<!-- more -->


<p>这种解析方式通常是没有问题，但是是不完整的。<a href="http://tools.ietf.org/html/rfc4180"><strong>RFC 4180</strong></a>是CSV格式的标准，这里提到并没有官方的规范去定义CSV的格式到底是怎样的，但是根据大多数的实现来看，应该有如下格式：</p>

<ul>
<li><p>每条数据用换行符（CRLF）分割。</p></li>
<li><p>最后一条数据可以不包含换行符。</p></li>
<li><p>可选的header行，如有的话，应该出现在第一行，并且与下面的数据有相同数量的字段。</p></li>
<li><p>在header和每条数据中，使用逗号“,”分隔字段，每一行都应该包含相同数量的字段，空白字符也可作为一个字段，一条数据的最后一个字段不应添加逗号分隔符。</p></li>
<li><p>每个字段可以包含在双引号中。</p></li>
<li><p>如果字段中包含换行符（CRLF），双引号和逗号，则必须将字段包含在双引号中。</p></li>
<li><p>如果字段中包含双引号，则除了需要将字段包含在双引号中，还要在字段中的双引号前再加一个双引号作为转义。</p></li>
</ul>


<p>由此可见，字段中是允许出现换行符的，只要该字段是包含在双引号中的。我也查阅了Spring Batch的CSV Reader的实现，也考虑到了该问题，在发现换行符的同时，也会检查当前字段是否已结束。</p>

<p>因此，我们在生成或解析CSV文件时，应该要考虑到以上特殊字符的处理，在apache的common-lang包中，也有专门针对CSV字符的转义方法，可参考<a href="http://commons.apache.org/proper/commons-lang/javadocs/api-release/org/apache/commons/lang3/StringEscapeUtils.html">StringEscapeUtils</a>，在最大程度上保证系统的robust。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM运行时内存区域]]></title>
    <link href="http://askcuix.github.io/blog/2013/03/26/the-runtime-memory-of-jvm/"/>
    <updated>2013-03-26T23:31:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2013/03/26/the-runtime-memory-of-jvm</id>
    <content type="html"><![CDATA[<p>Java虚拟机管理的运行时数据区域：</p>

<ul>
<li><p>程序计数器</p>

<p>是当前线程所执行的字节码的行号指示器。每条线程都有一个独立的程序计数器，各线程之间的计数器互不影响，该内存区域为线程私有，也不会出现OutOfMemoryError。</p></li>
<li><p>Java虚拟机栈</p>

<p>该区域也是线程私有，其生命周期与线程相同。虚拟机栈表述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>

<p><!-- more --></p>

<p>局部变量表存放了编译期可知的基本类型、对象引用（可能是一个指向对象起始地址的指针，也可能是指向一个对象的句柄，或者是与此对象相关的位置）和retuanAddress类型。64位长度的long和double类型占用2个局部变量空间，其余类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，方法运行期间不会改变。</p>

<p>在本区域中，若线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError；若动态扩展无法申请到足够的内存时抛出OutOfMemoryError。</p></li>
<li><p>本地方法栈</p>

<p>与虚拟机栈的作用相似，区别是虚拟机栈为虚拟机执行Java方法服务，本地方法栈为虚拟机使用到的Native方法服务。有的虚拟机实现会将虚拟机栈和本地方法栈合在一起。</p></li>
<li><p>Java堆</p>

<p>可被所有线程共享，在虚拟机启动时创建。此区域只用于存放对象实例，是垃圾收集器管理的主要区域。堆的扩展可通过-Xmx和-Xms控制。若堆中没有内存完成实例分配，也无法扩展时，将抛出OutOfMemoryError。</p></li>
<li><p>方法区</p>

<p>可被所有线程共享，用于存放已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虚拟机规范将方法区描述为堆的一个逻辑部分。该区域很少进行垃圾回收的操作。</p>

<p>若方法区无法满足内存分配需求时，将抛出OutOfMemoryError。</p></li>
</ul>


<h2>对象访问方式</h2>

<p>虚拟机规范中未定义对象访问的方式，在主要的虚拟机实现中包含如下两种方式：</p>

<ul>
<li><p>句柄访问</p>

<p>在Java堆中划分出一块内存作为句柄池，Java栈中对象引用存储的就是对象的句柄地址，句柄中包含了对象实例数据和类型数据的地址信息。</p>

<p>这种方式在对象引用中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，对象引用本身不需要被修改。</p></li>
<li><p>指针访问</p>

<p>Java栈中对象引用存储的就是对象的地址。这种方法的访问速度更快，节省了一次指针定位的开销。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Supplementary Characters in Java]]></title>
    <link href="http://askcuix.github.io/blog/2013/03/15/supplementary-characters-in-java/"/>
    <updated>2013-03-15T23:37:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2013/03/15/supplementary-characters-in-java</id>
    <content type="html"><![CDATA[<p>工作中经常会涉及到文件处理，而fixlength类型的文件又是一种很常见的格式。众所周知，fixlength类型的数据就是每个字段对应一行数据中固定长度的字符，每个字段都有对应的start offset和end offset，用实现来表示就是String.substring(start, end)，所以start和end的位置是至关重要的，一个字段对应错了，后面的字段就全错了。</p>

<p>在Java中使用UTF-16来表示unicode字符，一个字符就是16 bit，像String.length()就是返回有多少个16 bit。unicode支持的字符的code point范围是U+0000到U+10FFFF，这其中包括基本字符（BMP）和补充字符（supplementary character），基本字符时从U+0000到U+FFFF，补充字符从U+10000到U+10FFFF。<!-- more -->在UTF-16编码中，基本字符占用一个16 bit，而补充字符占用两个16 bit。这样Java String的很多方法就会出现问题了，当然也包括上面提到的substring和length。那么如果fixlength文件中含有补充字符，则会导致字段map错误。</p>

<p>那现在来看如何解决这个问题，一个解决办法是对字符串做Base64编码，编码之后的字符都是单个16 bit了。但是这有两个弊端，一是Base64之后会使数据变大，有时我们会将这些fixlength的数据作为JMS Message，对于这种情况，数据变大是不建议的；另一个问题是Base64操作的CPU消耗会比较大，会影响到performance。因此虽然这种方法可以解决问题，但是不推荐。</p>

<p>另一个解决办法是使用IBM的ICU4J，这个API提供了很多国际化相关的工具类，使用它来重新实现我们用到的String方法，这里可以参考我写的一个工具类<a href="https://github.com/askcuix/easeframe/blob/master/modules/core/src/main/java/com/easeframe/core/lang/Unicode.java">Unicode</a>。</p>

<p>因为我们一直用Spring Batch来处理文件，便查阅了一下源码看有没有考虑到supplementary character的问题，结果这个问题也被忽视了，看来supplementary character的使用还是比较少，但如果系统需要支持多语言的环境，还是自己处理一下比较好，之后我会重写一个Spring Batch的FixLengthItemWriter，增加对supplementary character的支持。</p>

<p>这里有一些资源可供参考：</p>

<ul>
<li><a href="http://www.unicode.org">unicode.org</a></li>
<li><a href="http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html">Supplementary Characters in the Java Platform</a></li>
<li><a href="http://docs.oracle.com/javase/tutorial/i18n/text/index.html">Working with Text</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The syntax of markdown]]></title>
    <link href="http://askcuix.github.io/blog/2013/03/10/the-syntax-of-markdown/"/>
    <updated>2013-03-10T17:36:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2013/03/10/the-syntax-of-markdown</id>
    <content type="html"><![CDATA[<p>Octopress使用的是markdown语法，和wiki的语法有点相似，但又不完全相同，这里将常用的语法记录下来便于查阅。</p>

<h2>标题</h2>

<p>标题用#开头，一个#是一级标题，两个#是二级标题，#越多字体越小。</p>

<!-- more -->


<h2>换行</h2>

<p>在每一行的末尾以两个或更多个空格符号结束，然后再打回车键，即可实现 <code>&lt;br /&gt;</code>的效果。</p>

<h2>链接</h2>

<p><code>[text](link)</code>
创建文本链接。</p>

<h2>图片</h2>

<p>与链接类似，区别是前面增加叹号!：</p>

<p><code>![text](link)</code></p>

<h2>引用</h2>

<p>用<code>&gt;</code>开头的一个段落。</p>

<p>用四个空格缩进的段落，会按原始格式显示。也可以通过在引用段落的前后各加一行波浪号~~~~~~来实现。</p>

<h2>显示效果</h2>

<p>用<code>*</code>或<code>_</code>包围的文字会用斜体显示。</p>

<p>双重符号<code>**</code>或<code>__</code>则会用粗体显示。</p>

<p>用`包围的文字按代码格式显示。</p>

<h2>列表</h2>

<p>无序列表用*, +, -开头。子项缩进两个空格。</p>

<p>有序列表用数字加英文句点。</p>

<h2>水平线</h2>

<p>在一行里只放三个或更多个<code>\</code>，或<code>*</code>或<code>_</code>，就可以实现水平线标记<code>&lt;hr /&gt;</code></p>

<h2>脚注</h2>

<p>以<code>[^1]:</code> 开头，后面跟着定义。</p>

<h2>嵌入代码</h2>

<pre><code> ``` [language] [title] [url] [link text]
   code snippet
 ```
</code></pre>

<h2>转义</h2>

<p>用<code>\</code>可转义Markdown元字符。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress常用命令]]></title>
    <link href="http://askcuix.github.io/blog/2013/03/10/the-common-commands-of-octopress/"/>
    <updated>2013-03-10T17:34:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2013/03/10/the-common-commands-of-octopress</id>
    <content type="html"><![CDATA[<p>Octopress经常使用到的命令，在这里做个总结，方面查阅。</p>

<pre><code>rake new_post["title"]
</code></pre>

<p>创建一个post。</p>

<pre><code>rake new_page[super-awesome/page.html]
</code></pre>

<p>创建一个page。</p>

<!-- more -->


<pre><code>&lt;!-- more --&gt;
</code></pre>

<p>插入到文章当中，用来实现摘要模式。</p>

<pre><code>keywords: 
description: 
</code></pre>

<p>在post和page开头添加以上两项属性，可更改Octopress默认的keywords和description，以提高SEO。</p>

<pre><code>rake generate
</code></pre>

<p>生成post/page。</p>

<pre><code>rake preview
</code></pre>

<p>预览效果：http://localhost:4000</p>

<pre><code>rake deploy
</code></pre>

<p>deploy到github。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[New Blog Opening]]></title>
    <link href="http://askcuix.github.io/blog/2013/03/06/new-blog-opening/"/>
    <updated>2013-03-06T23:42:00+08:00</updated>
    <id>http://askcuix.github.io/blog/2013/03/06/new-blog-opening</id>
    <content type="html"><![CDATA[<p>新blog开张啦，以此博文作为纪念。</p>

<p>这些年折腾了好几个博客了，但加起来的文字总共也没有多少，我的热乎劲也就在搭建那一刹那，特别是像在GAE上要自己去折腾整个过程。所以说，我并不热衷于写博客，而是中意于搭建这样一个小站的过程。说到原因呢，可能是因为哥曾经也是个web developer，但最近几年一直在做backend，把以前的frontend功底也丢的差不多了，所以每次遇到这样的机会，总是会让我心潮澎湃。</p>

<!-- more -->


<p>Github是developer的聚集地，尤其是开源爱好者们，搭建这个blog也是为了更亲近这个社区，octopress被很多developer用来在Github上搭建blog，也想了解下，顺便沾染点geeker的感觉。</p>

<p>以前从没接触过ruby，也不知什么原因，就是对它没兴趣，我更愿意去用python，结果这次的搭建过程真叫折腾。从在Mac上安装ruby，到彻底安装上octopress，不断的遇到gcc，make，openssl等问题，不知道重试了多少遍，最后还是按照ruby China上的wiki，用了淘宝的mirror才安装成功。Linux功底不行啊，对这些问题完全束手无策。</p>

<p>不知道会在这个blog上写多少东西，准备在这里纪录一些学习笔记，平时很多东西都记录在Evernote上了，今后可以选择性的放一些在这里。前面也说过了，我并不擅长于写博客，因为我的文笔实在不咋地，写一篇拿出来见人的东西要花费很长时间，慢慢地也就没了兴趣，另一方面，自己也确实缺乏毅力，总是没能坚持写下去。我希望自己对待这个blog能有点毅力，既是对自己学习过程的监督，也是对写作能力的培养。</p>

<p><strong><em>Keep Walking……</em></strong></p>
]]></content>
  </entry>
  
</feed>

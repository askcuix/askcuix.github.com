<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Chris's Blog]]></title>
  <link href="http://askcuix.github.com/atom.xml" rel="self"/>
  <link href="http://askcuix.github.com/"/>
  <updated>2013-03-27T00:25:49+08:00</updated>
  <id>http://askcuix.github.com/</id>
  <author>
    <name><![CDATA[Chris]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Common Format of CSV Files]]></title>
    <link href="http://askcuix.github.com/blog/2013/03/26/common-format-of-csv-files/"/>
    <updated>2013-03-26T23:43:00+08:00</updated>
    <id>http://askcuix.github.com/blog/2013/03/26/common-format-of-csv-files</id>
    <content type="html"><![CDATA[<p>CSV是一种常见的文件格式，常用于不同系统之间的数据交换，对于该文件格式可以简单描述为：一组使用逗号“,”分隔字段，并以换行符作为一行数据结束的数据集合。该文件可以使用Microsoft Excel查看，但是中文字符会显示为乱码。</p>

<p>这个描述就真的只是简单描述，实际上CSV的格式处理没有这么简单。最近在和另外一个系统做集成，我们的系统会提供CSV数据文件给对方系统处理，由于我们系统中个别字段会包括换行符“CRLF”（这是遗留系统，就不用纠结为什么字段中会包含换行符了），也就是说一个字段可能会显示在几行上，但是这个字段是包含在双引号中的，结果对方系统就处理不了了。因为对方系统只是简单的按行处理数据，用逗号解析字段。</p>

<!-- more -->


<p>这种解析方式通常是没有问题，但是是不完整的。<a href="http://tools.ietf.org/html/rfc4180"><strong>RFC 4180</strong></a>是CSV格式的标准，这里提到并没有官方的规范去定义CSV的格式到底是怎样的，但是根据大多数的实现来看，应该有如下格式：</p>

<ul>
<li><p>每条数据用换行符（CRLF）分割。</p></li>
<li><p>最后一条数据可以不包含换行符。</p></li>
<li><p>可选的header行，如有的话，应该出现在第一行，并且与下面的数据有相同数量的字段。</p></li>
<li><p>在header和每条数据中，使用逗号“,”分隔字段，每一行都应该包含相同数量的字段，空白字符也可作为一个字段，一条数据的最后一个字段不应添加逗号分隔符。</p></li>
<li><p>每个字段可以包含在双引号中。</p></li>
<li><p>如果字段中包含换行符（CRLF），双引号和逗号，则必须将字段包含在双引号中。</p></li>
<li><p>如果字段中包含双引号，则除了需要将字段包含在双引号中，还要在字段中的双引号前再加一个双引号作为转义。</p></li>
</ul>


<p>由此可见，字段中是允许出现换行符的，只要该字段是包含在双引号中的。我也查阅了Spring Batch的CSV Reader的实现，也考虑到了该问题，在发现换行符的同时，也会检查当前字段是否已结束。</p>

<p>因此，我们在生成或解析CSV文件时，应该要考虑到以上特殊字符的处理，在apache的common-lang包中，也有专门针对CSV字符的转义方法，可参考<a href="http://commons.apache.org/proper/commons-lang/javadocs/api-release/org/apache/commons/lang3/StringEscapeUtils.html">StringEscapeUtils</a>，在最大程度上保证系统的robust。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM运行时内存区域]]></title>
    <link href="http://askcuix.github.com/blog/2013/03/26/the-runtime-memory-of-jvm/"/>
    <updated>2013-03-26T23:31:00+08:00</updated>
    <id>http://askcuix.github.com/blog/2013/03/26/the-runtime-memory-of-jvm</id>
    <content type="html"><![CDATA[<p>Java虚拟机管理的运行时数据区域：</p>

<ul>
<li><p>程序计数器</p>

<p>是当前线程所执行的字节码的行号指示器。每条线程都有一个独立的程序计数器，各线程之间的计数器互不影响，该内存区域为线程私有，也不会出现OutOfMemoryError。</p></li>
<li><p>Java虚拟机栈</p>

<p>该区域也是线程私有，其生命周期与线程相同。虚拟机栈表述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>

<p><!-- more --></p>

<p>局部变量表存放了编译期可知的基本类型、对象引用（可能是一个指向对象起始地址的指针，也可能是指向一个对象的句柄，或者是与此对象相关的位置）和retuanAddress类型。64位长度的long和double类型占用2个局部变量空间，其余类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，方法运行期间不会改变。</p>

<p>在本区域中，若线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError；若动态扩展无法申请到足够的内存时抛出OutOfMemoryError。</p></li>
<li><p>本地方法栈</p>

<p>与虚拟机栈的作用相似，区别是虚拟机栈为虚拟机执行Java方法服务，本地方法栈为虚拟机使用到的Native方法服务。有的虚拟机实现会将虚拟机栈和本地方法栈合在一起。</p></li>
<li><p>Java堆</p>

<p>可被所有线程共享，在虚拟机启动时创建。此区域只用于存放对象实例，是垃圾收集器管理的主要区域。堆的扩展可通过-Xmx和-Xms控制。若堆中没有内存完成实例分配，也无法扩展时，将抛出OutOfMemoryError。</p></li>
<li><p>方法区</p>

<p>可被所有线程共享，用于存放已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虚拟机规范将方法区描述为堆的一个逻辑部分。该区域很少进行垃圾回收的操作。</p>

<p>若方法区无法满足内存分配需求时，将抛出OutOfMemoryError。</p></li>
</ul>


<h2>对象访问方式</h2>

<p>虚拟机规范中未定义对象访问的方式，在主要的虚拟机实现中包含如下两种方式：</p>

<ul>
<li><p>句柄访问</p>

<p>在Java堆中划分出一块内存作为句柄池，Java栈中对象引用存储的就是对象的句柄地址，句柄中包含了对象实例数据和类型数据的地址信息。</p>

<p>这种方式在对象引用中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，对象引用本身不需要被修改。</p></li>
<li><p>指针访问</p>

<p>Java栈中对象引用存储的就是对象的地址。这种方法的访问速度更快，节省了一次指针定位的开销。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Supplementary Characters in Java]]></title>
    <link href="http://askcuix.github.com/blog/2013/03/15/supplementary-characters-in-java/"/>
    <updated>2013-03-15T23:37:00+08:00</updated>
    <id>http://askcuix.github.com/blog/2013/03/15/supplementary-characters-in-java</id>
    <content type="html"><![CDATA[<p>工作中经常会涉及到文件处理，而fixlength类型的文件又是一种很常见的格式。众所周知，fixlength类型的数据就是每个字段对应一行数据中固定长度的字符，每个字段都有对应的start offset和end offset，用实现来表示就是String.substring(start, end)，所以start和end的位置是至关重要的，一个字段对应错了，后面的字段就全错了。</p>

<p>在Java中使用UTF-16来表示unicode字符，一个字符就是16 bit，像String.length()就是返回有多少个16 bit。unicode支持的字符的code point范围是U+0000到U+10FFFF，这其中包括基本字符（BMP）和补充字符（supplementary character），基本字符时从U+0000到U+FFFF，补充字符从U+10000到U+10FFFF。<!-- more -->在UTF-16编码中，基本字符占用一个16 bit，而补充字符占用两个16 bit。这样Java String的很多方法就会出现问题了，当然也包括上面提到的substring和length。那么如果fixlength文件中含有补充字符，则会导致字段map错误。</p>

<p>那现在来看如何解决这个问题，一个解决办法是对字符串做Base64编码，编码之后的字符都是单个16 bit了。但是这有两个弊端，一是Base64之后会使数据变大，有时我们会将这些fixlength的数据作为JMS Message，对于这种情况，数据变大是不建议的；另一个问题是Base64操作的CPU消耗会比较大，会影响到performance。因此虽然这种方法可以解决问题，但是不推荐。</p>

<p>另一个解决办法是使用IBM的ICU4J，这个API提供了很多国际化相关的工具类，使用它来重新实现我们用到的String方法，这里可以参考我写的一个工具类<a href="https://github.com/askcuix/easeframe/blob/master/modules/core/src/main/java/com/easeframe/core/lang/Unicode.java">Unicode</a>。</p>

<p>因为我们一直用Spring Batch来处理文件，便查阅了一下源码看有没有考虑到supplementary character的问题，结果这个问题也被忽视了，看来supplementary character的使用还是比较少，但如果系统需要支持多语言的环境，还是自己处理一下比较好，之后我会重写一个Spring Batch的FixLengthItemWriter，增加对supplementary character的支持。</p>

<p>这里有一些资源可供参考：</p>

<ul>
<li><a href="http://www.unicode.org">unicode.org</a></li>
<li><a href="http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html">Supplementary Characters in the Java Platform</a></li>
<li><a href="http://docs.oracle.com/javase/tutorial/i18n/text/index.html">Working with Text</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The syntax of markdown]]></title>
    <link href="http://askcuix.github.com/blog/2013/03/10/the-syntax-of-markdown/"/>
    <updated>2013-03-10T17:36:00+08:00</updated>
    <id>http://askcuix.github.com/blog/2013/03/10/the-syntax-of-markdown</id>
    <content type="html"><![CDATA[<p>Octopress使用的是markdown语法，和wiki的语法有点相似，但又不完全相同，这里将常用的语法记录下来便于查阅。</p>

<h2>标题</h2>

<p>标题用#开头，一个#是一级标题，两个#是二级标题，#越多字体越小。</p>

<!-- more -->


<h2>换行</h2>

<p>在每一行的末尾以两个或更多个空格符号结束，然后再打回车键，即可实现 <code>&lt;br /&gt;</code>的效果。</p>

<h2>链接</h2>

<p><code>[text](link)</code>
创建文本链接。</p>

<h2>图片</h2>

<p>与链接类似，区别是前面增加叹号!：</p>

<p><code>![text](link)</code></p>

<h2>引用</h2>

<p>用<code>&gt;</code>开头的一个段落。</p>

<p>用四个空格缩进的段落，会按原始格式显示。也可以通过在引用段落的前后各加一行波浪号~~~~~~来实现。</p>

<h2>显示效果</h2>

<p>用<code>*</code>或<code>_</code>包围的文字会用斜体显示。</p>

<p>双重符号<code>**</code>或<code>__</code>则会用粗体显示。</p>

<p>用`包围的文字按代码格式显示。</p>

<h2>列表</h2>

<p>无序列表用*, +, -开头。子项缩进两个空格。</p>

<p>有序列表用数字加英文句点。</p>

<h2>水平线</h2>

<p>在一行里只放三个或更多个<code>\</code>，或<code>*</code>或<code>_</code>，就可以实现水平线标记<code>&lt;hr /&gt;</code></p>

<h2>脚注</h2>

<p>以<code>[^1]:</code> 开头，后面跟着定义。</p>

<h2>嵌入代码</h2>

<pre><code> ``` [language] [title] [url] [link text]
   code snippet
 ```
</code></pre>

<h2>转义</h2>

<p>用<code>\</code>可转义Markdown元字符。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress常用命令]]></title>
    <link href="http://askcuix.github.com/blog/2013/03/10/the-common-commands-of-octopress/"/>
    <updated>2013-03-10T17:34:00+08:00</updated>
    <id>http://askcuix.github.com/blog/2013/03/10/the-common-commands-of-octopress</id>
    <content type="html"><![CDATA[<p>Octopress经常使用到的命令，在这里做个总结，方面查阅。</p>

<pre><code>rake new_post["title"]
</code></pre>

<p>创建一个post。</p>

<pre><code>rake new_page[super-awesome/page.html]
</code></pre>

<p>创建一个page。</p>

<!-- more -->


<pre><code>&lt;!-- more --&gt;
</code></pre>

<p>插入到文章当中，用来实现摘要模式。</p>

<pre><code>rake generate
</code></pre>

<p>生成post/page。</p>

<pre><code>rake preview
</code></pre>

<p>预览效果：http://localhost:4000</p>

<pre><code>rake deploy
</code></pre>

<p>deploy到github。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[New Blog Opening]]></title>
    <link href="http://askcuix.github.com/blog/2013/03/06/new-blog-opening/"/>
    <updated>2013-03-06T23:42:00+08:00</updated>
    <id>http://askcuix.github.com/blog/2013/03/06/new-blog-opening</id>
    <content type="html"><![CDATA[<p>新blog开张啦，以此博文作为纪念。</p>

<p>这些年折腾了好几个博客了，但加起来的文字总共也没有多少，我的热乎劲也就在搭建那一刹那，特别是像在GAE上要自己去折腾整个过程。所以说，我并不热衷于写博客，而是中意于搭建这样一个小站的过程。说到原因呢，可能是因为哥曾经也是个web developer，但最近几年一直在做backend，把以前的frontend功底也丢的差不多了，所以每次遇到这样的机会，总是会让我心潮澎湃。</p>

<!-- more -->


<p>Github是developer的聚集地，尤其是开源爱好者们，搭建这个blog也是为了更亲近这个社区，octopress被很多developer用来在Github上搭建blog，也想了解下，顺便沾染点geeker的感觉。</p>

<p>以前从没接触过ruby，也不知什么原因，就是对它没兴趣，我更愿意去用python，结果这次的搭建过程真叫折腾。从在Mac上安装ruby，到彻底安装上octopress，不断的遇到gcc，make，openssl等问题，不知道重试了多少遍，最后还是按照ruby China上的wiki，用了淘宝的mirror才安装成功。Linux功底不行啊，对这些问题完全束手无策。</p>

<p>不知道会在这个blog上写多少东西，准备在这里纪录一些学习笔记，平时很多东西都记录在Evernote上了，今后可以选择性的放一些在这里。前面也说过了，我并不擅长于写博客，因为我的文笔实在不咋地，写一篇拿出来见人的东西要花费很长时间，慢慢地也就没了兴趣，另一方面，自己也确实缺乏毅力，总是没能坚持写下去。我希望自己对待这个blog能有点毅力，既是对自己学习过程的监督，也是对写作能力的培养。</p>

<p><strong><em>Keep Walking……</em></strong></p>
]]></content>
  </entry>
  
</feed>
